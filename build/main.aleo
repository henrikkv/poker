import zk_deck_shuffle.aleo;
import zk_sra_encryption.aleo;
program poker.aleo;

struct Game:
    player1 as address;
    player2 as address;
    player3 as address;
    buy_in as u64;
    deck as [[u128; 26u32]; 2u32];
    state as u8;
    dealer_button as u8;
    players_out as u8;
    last_bet as u8;

struct Chips:
    player1 as u16;
    player2 as u16;
    player3 as u16;
    player1_bet as u16;
    player2_bet as u16;
    player3_bet as u16;

struct Cards:
    player1 as [u128; 2u32];
    player2 as [u128; 2u32];
    player3 as [u128; 2u32];
    flop as [u128; 3u32];
    turn as u128;
    river as u128;

mapping games:
    key as u32.public;
    value as Game.public;

mapping chips:
    key as u32.public;
    value as Chips.public;

mapping cards:
    key as u32.public;
    value as Cards.public;

function create_game:
    input r0 as u32.private;
    input r1 as i8.private;
    input r2 as i8.private;
    input r3 as i8.private;
    input r4 as u128.private;
    input r5 as u128.private;
    cast  1u128 2u128 3u128 4u128 5u128 6u128 7u128 8u128 9u128 10u128 11u128 12u128 13u128 14u128 15u128 16u128 17u128 18u128 19u128 20u128 21u128 22u128 23u128 24u128 25u128 26u128 into r6 as [u128; 26u32];
    cast  27u128 28u128 29u128 30u128 31u128 32u128 33u128 34u128 35u128 36u128 37u128 38u128 39u128 40u128 41u128 42u128 43u128 44u128 45u128 46u128 47u128 48u128 49u128 50u128 51u128 52u128 into r7 as [u128; 26u32];
    cast  r6 r7 into r8 as [[u128; 26u32]; 2u32];
    call zk_sra_encryption.aleo/encrypt_deck r4 r5 r8 into r9;
    call zk_deck_shuffle.aleo/full_shuffle r1 r2 r3 r9 into r10;
    async create_game r0 r10 self.caller into r11;
    output r11 as poker.aleo/create_game.future;

finalize create_game:
    input r0 as u32.public;
    input r1 as [[u128; 26u32]; 2u32].public;
    input r2 as address.public;
    cast 0u128 into r3 as address;
    cast 0u128 into r4 as address;
    cast r2 r3 r4 10u64 r1 0u8 4u8 0u8 0u8 into r5 as Game;
    set r5 into games[r0];

function join_game:
    input r0 as u32.private;
    input r1 as [[u128; 26u32]; 2u32].private;
    input r2 as i8.private;
    input r3 as i8.private;
    input r4 as i8.private;
    input r5 as u128.private;
    input r6 as u128.private;
    call zk_sra_encryption.aleo/encrypt_deck r5 r6 r1 into r7;
    call zk_deck_shuffle.aleo/full_shuffle r2 r3 r4 r7 into r8;
    async join_game r0 r1 r8 self.caller into r9;
    output r9 as poker.aleo/join_game.future;

finalize join_game:
    input r0 as u32.public;
    input r1 as [[u128; 26u32]; 2u32].public;
    input r2 as [[u128; 26u32]; 2u32].public;
    input r3 as address.public;
    get games[r0] into r4;
    is.eq r4.deck r1 into r5;
    assert.eq r5 true;
    is.eq r4.state 0u8 into r6;
    branch.eq r6 false to end_then_0_0;
    cast 0u128 into r7 as address;
    cast r4.player1 r3 r7 r4.buy_in r2 1u8 4u8 0u8 0u8 into r8 as Game;
    set r8 into games[r0];
    branch.eq true true to end_otherwise_0_1;
    position end_then_0_0;
    is.eq r4.state 1u8 into r9;
    branch.eq r9 false to end_then_1_2;
    cast r4.player1 r4.player2 r3 r4.buy_in r2 2u8 3u8 0u8 0u8 into r10 as Game;
    cast 1000u16 1000u16 1000u16 0u16 0u16 0u16 into r11 as Chips;
    cast  r2[1u32][1u32] r2[1u32][4u32] into r12 as [u128; 2u32];
    cast  r2[1u32][2u32] r2[1u32][5u32] into r13 as [u128; 2u32];
    cast  r2[1u32][3u32] r2[1u32][6u32] into r14 as [u128; 2u32];
    cast  r2[1u32][7u32] r2[1u32][8u32] r2[1u32][9u32] into r15 as [u128; 3u32];
    cast r12 r13 r14 r15 r2[1u32][10u32] r2[1u32][11u32] into r16 as Cards;
    set r10 into games[r0];
    set r11 into chips[r0];
    set r16 into cards[r0];
    branch.eq true true to end_otherwise_1_3;
    position end_then_1_2;
    position end_otherwise_1_3;
    position end_otherwise_0_1;

function bet:
    input r0 as u32.private;
    input r1 as u16.private;
    async bet r0 r1 self.caller into r2;
    output r2 as poker.aleo/bet.future;

finalize bet:
    input r0 as u32.public;
    input r1 as u16.public;
    input r2 as address.public;
    get games[r0] into r3;
    get chips[r0] into r4;
    is.eq r3.state 4u8 into r5;
    is.eq r3.player1 r2 into r6;
    and r5 r6 into r7;
    is.eq r3.state 5u8 into r8;
    is.eq r3.player2 r2 into r9;
    and r8 r9 into r10;
    or r7 r10 into r11;
    is.eq r3.state 6u8 into r12;
    is.eq r3.player3 r2 into r13;
    and r12 r13 into r14;
    or r11 r14 into r15;
    assert.eq r15 true;
    is.eq r3.state 4u8 into r16;
    is.eq r3.state 5u8 into r17;
    ternary r17 r4.player2 r4.player3 into r18;
    ternary r17 r4.player2_bet r4.player3_bet into r19;
    ternary r16 r4.player1 r18 into r20;
    ternary r16 r4.player1_bet r19 into r21;
    gte r4.player1_bet r4.player2_bet into r22;
    gte r4.player1_bet r4.player3_bet into r23;
    and r22 r23 into r24;
    gte r4.player2_bet r4.player3_bet into r25;
    ternary r25 r4.player2_bet r4.player3_bet into r26;
    ternary r24 r4.player1_bet r26 into r27;
    sub r27 r21 into r28;
    lte r1 r20 into r29;
    assert.eq r29 true;
    is.eq r1 r20 into r30;
    gte r1 r28 into r31;
    or r30 r31 into r32;
    assert.eq r32 true;
    add r21 r1 into r33;
    sub r20 r1 into r34;
    is.eq r4.player1 0u16 into r35;
    and r3.players_out 1u8 into r36;
    is.neq r36 0u8 into r37;
    or r35 r37 into r38;
    is.eq r4.player2 0u16 into r39;
    and r3.players_out 2u8 into r40;
    is.neq r40 0u8 into r41;
    or r39 r41 into r42;
    is.eq r4.player3 0u16 into r43;
    and r3.players_out 4u8 into r44;
    is.neq r44 0u8 into r45;
    or r43 r45 into r46;
    is.eq r34 0u16 into r47;
    is.eq r3.state 4u8 into r48;
    ternary r46 8u8 6u8 into r49;
    ternary r42 r49 5u8 into r50;
    is.eq r3.state 5u8 into r51;
    ternary r38 8u8 4u8 into r52;
    ternary r46 r52 6u8 into r53;
    ternary r42 8u8 5u8 into r54;
    ternary r38 r54 4u8 into r55;
    ternary r51 r53 r55 into r56;
    ternary r48 r50 r56 into r57;
    is.eq r1 0u16 into r58;
    is.eq r21 r27 into r59;
    or r59 r47 into r60;
    and r58 r60 into r61;
    gte r33 r27 into r62;
    or r62 r47 into r63;
    gt r33 r27 into r64;
    not r47 into r65;
    and r64 r65 into r66;
    is.eq r3.state 4u8 into r67;
    is.eq r3.state 5u8 into r68;
    ternary r68 2u8 4u8 into r69;
    ternary r67 1u8 r69 into r70;
    ternary r66 r70 r3.last_bet into r71;
    ternary r63 r57 r3.state into r72;
    ternary r63 r71 r3.last_bet into r73;
    ternary r61 r57 r72 into r74;
    ternary r61 r3.last_bet r73 into r75;
    is.eq r4.player1_bet r27 into r76;
    or r38 r76 into r77;
    is.eq r4.player2_bet r27 into r78;
    or r42 r78 into r79;
    and r77 r79 into r80;
    is.eq r4.player3_bet r27 into r81;
    or r46 r81 into r82;
    and r80 r82 into r83;
    ternary r83 8u8 r74 into r84;
    is.eq r3.state 4u8 into r85;
    ternary r85 r34 r4.player1 into r86;
    is.eq r3.state 5u8 into r87;
    ternary r87 r34 r4.player2 into r88;
    is.eq r3.state 6u8 into r89;
    ternary r89 r34 r4.player3 into r90;
    is.eq r3.state 4u8 into r91;
    ternary r91 r33 r4.player1_bet into r92;
    is.eq r3.state 5u8 into r93;
    ternary r93 r33 r4.player2_bet into r94;
    is.eq r3.state 6u8 into r95;
    ternary r95 r33 r4.player3_bet into r96;
    cast r86 r88 r90 r92 r94 r96 into r97 as Chips;
    cast r3.player1 r3.player2 r3.player3 r3.buy_in r3.deck r84 r3.dealer_button r3.players_out r75 into r98 as Game;
    set r97 into chips[r0];
    set r98 into games[r0];

function decrypt_hands_p1:
    input r0 as u32.private;
    input r1 as u128.private;
    input r2 as u128.private;
    input r3 as Cards.private;
    call zk_sra_encryption.aleo/decrypt_card r1 r2 r3.player2[0u32] into r4;
    call zk_sra_encryption.aleo/decrypt_card r1 r2 r3.player2[1u32] into r5;
    cast  r4 r5 into r6 as [u128; 2u32];
    call zk_sra_encryption.aleo/decrypt_card r1 r2 r3.player3[0u32] into r7;
    call zk_sra_encryption.aleo/decrypt_card r1 r2 r3.player3[1u32] into r8;
    cast  r7 r8 into r9 as [u128; 2u32];
    cast r3.player1 r6 r9 r3.flop r3.turn r3.river into r10 as Cards;
    async decrypt_hands_p1 r0 r3 r10 self.caller into r11;
    output r11 as poker.aleo/decrypt_hands_p1.future;

finalize decrypt_hands_p1:
    input r0 as u32.public;
    input r1 as Cards.public;
    input r2 as Cards.public;
    input r3 as address.public;
    get cards[r0] into r4;
    is.eq r1 r4 into r5;
    assert.eq r5 true;
    get games[r0] into r6;
    is.eq r6.state 2u8 into r7;
    assert.eq r7 true;
    is.eq r6.player1 r3 into r8;
    assert.eq r8 true;
    and r6.players_out 2u8 into r9;
    is.neq r9 0u8 into r10;
    branch.eq r10 false to end_then_0_4;
    cast r6.player1 r6.player2 r6.player3 r6.buy_in r6.deck 4u8 r6.dealer_button r6.players_out r6.last_bet into r11 as Game;
    set r2 into cards[r0];
    set r11 into games[r0];
    branch.eq true true to end_otherwise_0_5;
    position end_then_0_4;
    cast r6.player1 r6.player2 r6.player3 r6.buy_in r6.deck 3u8 r6.dealer_button r6.players_out r6.last_bet into r12 as Game;
    set r2 into cards[r0];
    set r12 into games[r0];
    position end_otherwise_0_5;

function decrypt_hands_p2:
    input r0 as u32.private;
    input r1 as u128.private;
    input r2 as u128.private;
    input r3 as Cards.private;
    call zk_sra_encryption.aleo/decrypt_card r1 r2 r3.player1[0u32] into r4;
    call zk_sra_encryption.aleo/decrypt_card r1 r2 r3.player1[1u32] into r5;
    cast  r4 r5 into r6 as [u128; 2u32];
    call zk_sra_encryption.aleo/decrypt_card r1 r2 r3.player3[0u32] into r7;
    call zk_sra_encryption.aleo/decrypt_card r1 r2 r3.player3[1u32] into r8;
    cast  r7 r8 into r9 as [u128; 2u32];
    cast r6 r3.player2 r9 r3.flop r3.turn r3.river into r10 as Cards;
    async decrypt_hands_p2 r0 r3 r10 self.caller into r11;
    output r11 as poker.aleo/decrypt_hands_p2.future;

finalize decrypt_hands_p2:
    input r0 as u32.public;
    input r1 as Cards.public;
    input r2 as Cards.public;
    input r3 as address.public;
    get cards[r0] into r4;
    is.eq r1 r4 into r5;
    assert.eq r5 true;
    get games[r0] into r6;
    is.eq r6.state 3u8 into r7;
    assert.eq r7 true;
    is.eq r6.player2 r3 into r8;
    assert.eq r8 true;
    set r2 into cards[r0];
    and r6.players_out 4u8 into r9;
    is.neq r9 0u8 into r10;
    and r6.dealer_button 2u8 into r11;
    is.neq r11 0u8 into r12;
    ternary r12 5u8 6u8 into r13;
    ternary r10 r13 4u8 into r14;
    and r6.players_out 4u8 into r15;
    is.neq r15 0u8 into r16;
    and r6.dealer_button 2u8 into r17;
    is.neq r17 0u8 into r18;
    ternary r18 2u8 1u8 into r19;
    ternary r16 r19 r6.last_bet into r20;
    cast r6.player1 r6.player2 r6.player3 r6.buy_in r6.deck r14 r6.dealer_button r6.players_out r20 into r21 as Game;
    set r21 into games[r0];

function decrypt_hands_p3:
    input r0 as u32.private;
    input r1 as u128.private;
    input r2 as u128.private;
    input r3 as Cards.private;
    call zk_sra_encryption.aleo/decrypt_card r1 r2 r3.player1[0u32] into r4;
    call zk_sra_encryption.aleo/decrypt_card r1 r2 r3.player1[1u32] into r5;
    cast  r4 r5 into r6 as [u128; 2u32];
    call zk_sra_encryption.aleo/decrypt_card r1 r2 r3.player2[0u32] into r7;
    call zk_sra_encryption.aleo/decrypt_card r1 r2 r3.player2[1u32] into r8;
    cast  r7 r8 into r9 as [u128; 2u32];
    cast r6 r9 r3.player3 r3.flop r3.turn r3.river into r10 as Cards;
    async decrypt_hands_p3 r0 r3 r10 self.caller into r11;
    output r11 as poker.aleo/decrypt_hands_p3.future;

finalize decrypt_hands_p3:
    input r0 as u32.public;
    input r1 as Cards.public;
    input r2 as Cards.public;
    input r3 as address.public;
    get cards[r0] into r4;
    is.eq r1 r4 into r5;
    assert.eq r5 true;
    get games[r0] into r6;
    is.eq r6.state 4u8 into r7;
    assert.eq r7 true;
    is.eq r6.player3 r3 into r8;
    assert.eq r8 true;
    set r2 into cards[r0];
    and r6.players_out 1u8 into r9;
    is.neq r9 0u8 into r10;
    and r6.dealer_button 2u8 into r11;
    is.neq r11 0u8 into r12;
    ternary r12 7u8 6u8 into r13;
    and r6.players_out 2u8 into r14;
    is.neq r14 0u8 into r15;
    and r6.dealer_button 1u8 into r16;
    is.neq r16 0u8 into r17;
    ternary r17 7u8 5u8 into r18;
    and r6.players_out 4u8 into r19;
    is.neq r19 0u8 into r20;
    and r6.dealer_button 2u8 into r21;
    is.neq r21 0u8 into r22;
    ternary r22 5u8 6u8 into r23;
    and r6.dealer_button 1u8 into r24;
    is.neq r24 0u8 into r25;
    and r6.dealer_button 2u8 into r26;
    is.neq r26 0u8 into r27;
    ternary r27 5u8 6u8 into r28;
    ternary r25 7u8 r28 into r29;
    ternary r20 r23 r29 into r30;
    ternary r15 r18 r30 into r31;
    ternary r10 r13 r31 into r32;
    and r6.players_out 1u8 into r33;
    is.neq r33 0u8 into r34;
    and r6.dealer_button 2u8 into r35;
    is.neq r35 0u8 into r36;
    ternary r36 2u8 4u8 into r37;
    and r6.players_out 2u8 into r38;
    is.neq r38 0u8 into r39;
    and r6.dealer_button 1u8 into r40;
    is.neq r40 0u8 into r41;
    ternary r41 1u8 4u8 into r42;
    and r6.players_out 4u8 into r43;
    is.neq r43 0u8 into r44;
    and r6.dealer_button 2u8 into r45;
    is.neq r45 0u8 into r46;
    ternary r46 2u8 1u8 into r47;
    and r6.dealer_button 1u8 into r48;
    is.neq r48 0u8 into r49;
    and r6.dealer_button 2u8 into r50;
    is.neq r50 0u8 into r51;
    ternary r51 4u8 1u8 into r52;
    ternary r49 2u8 r52 into r53;
    ternary r44 r47 r53 into r54;
    ternary r39 r42 r54 into r55;
    ternary r34 r37 r55 into r56;
    cast r6.player1 r6.player2 r6.player3 r6.buy_in r6.deck r32 r6.dealer_button r6.players_out r56 into r57 as Game;
    set r57 into games[r0];
