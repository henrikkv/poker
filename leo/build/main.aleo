import zk_deck_shuffle.aleo;
import commutative_encryption.aleo;
program poker.aleo;

record Keys:
    owner as address.private;
    secret as scalar.private;
    secret_inv as scalar.private;

struct Game:
    player1 as address;
    player2 as address;
    player3 as address;
    buy_in as u64;
    deck as [[group; 26u32]; 2u32];
    state as u8;
    dealer_button as u8;
    players_out as u8;
    players_folded as u8;
    last_bet as u8;
    sb as u16;
    bb as u16;
    remaining_hands as u8;
    hands_played as u8;
    last_raise_size as u16;

struct Chips:
    player1 as u16;
    player2 as u16;
    player3 as u16;
    player1_bet as u16;
    player2_bet as u16;
    player3_bet as u16;

struct Cards:
    player1 as [group; 2u32];
    player2 as [group; 2u32];
    player3 as [group; 2u32];
    flop as [group; 3u32];
    turn as group;
    river as group;

mapping games:
    key as u32.public;
    value as Game.public;

mapping chips:
    key as u32.public;
    value as Chips.public;

mapping cards:
    key as u32.public;
    value as Cards.public;

function create_game:
    input r0 as u32.private;
    input r1 as i8.private;
    input r2 as i8.private;
    input r3 as i8.private;
    input r4 as scalar.private;
    input r5 as scalar.private;
    call commutative_encryption.aleo/initialize_deck into r6;
    call commutative_encryption.aleo/encrypt_deck r4 r6 into r7;
    call commutative_encryption.aleo/decrypt_card r5 r7[0u32][0u32] into r8;
    assert.eq r8 r6[0u32][0u32];
    cast self.caller r4 r5 into r9 as Keys.record;
    async create_game r0 r7 self.caller into r10;
    output r9 as Keys.record;
    output r10 as poker.aleo/create_game.future;

finalize create_game:
    input r0 as u32.public;
    input r1 as [[group; 26u32]; 2u32].public;
    input r2 as address.public;
    cast r2 aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc 10u64 r1 0u8 1u8 0u8 0u8 0u8 5u16 10u16 10u8 0u8 0u16 into r3 as Game;
    set r3 into games[r0];

function join_game:
    input r0 as u32.private;
    input r1 as [[group; 26u32]; 2u32].private;
    input r2 as i8.private;
    input r3 as i8.private;
    input r4 as i8.private;
    input r5 as scalar.private;
    input r6 as scalar.private;
    call commutative_encryption.aleo/encrypt_deck r5 r1 into r7;
    call commutative_encryption.aleo/decrypt_card r6 r7[0u32][0u32] into r8;
    assert.eq r8 r1[0u32][0u32];
    cast self.caller r5 r6 into r9 as Keys.record;
    async join_game r0 r1 r7 self.caller into r10;
    output r9 as Keys.record;
    output r10 as poker.aleo/join_game.future;

finalize join_game:
    input r0 as u32.public;
    input r1 as [[group; 26u32]; 2u32].public;
    input r2 as [[group; 26u32]; 2u32].public;
    input r3 as address.public;
    get games[r0] into r4;
    is.eq r4.deck r1 into r5;
    assert.eq r5 true;
    is.eq r4.state 0u8 into r6;
    is.eq r4.state 0u8 into r7;
    is.eq r4.state 1u8 into r8;
    or r7 r8 into r9;
    assert.eq r9 true;
    ternary r6 r3 r4.player2 into r10;
    not r6 into r11;
    ternary r11 r3 aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc into r12;
    ternary r6 1u8 2u8 into r13;
    cast r4.player1 r10 r12 r4.buy_in r2 r13 r4.dealer_button 0u8 0u8 0u8 r4.sb r4.bb r4.remaining_hands 0u8 0u16 into r14 as Game;
    set r14 into games[r0];
    not r6 into r15;
    branch.eq r15 false to end_then_0_0;
    sub 1000u16 r4.sb into r16;
    sub 1000u16 r4.bb into r17;
    cast r16 r17 1000u16 r4.sb r4.bb 0u16 into r18 as Chips;
    cast r2[1u32][1u32] r2[1u32][4u32] into r19 as [group; 2u32];
    cast r2[1u32][2u32] r2[1u32][5u32] into r20 as [group; 2u32];
    cast r2[1u32][3u32] r2[1u32][6u32] into r21 as [group; 2u32];
    cast r2[1u32][7u32] r2[1u32][8u32] r2[1u32][9u32] into r22 as [group; 3u32];
    cast r19 r20 r21 r22 r2[1u32][10u32] r2[1u32][11u32] into r23 as Cards;
    set r18 into chips[r0];
    set r23 into cards[r0];
    branch.eq true true to end_otherwise_0_1;
    position end_then_0_0;
    position end_otherwise_0_1;

function bet:
    input r0 as u32.private;
    input r1 as u16.private;
    async bet r0 r1 self.caller into r2;
    output r2 as poker.aleo/bet.future;

finalize bet:
    input r0 as u32.public;
    input r1 as u16.public;
    input r2 as address.public;
    get games[r0] into r3;
    get chips[r0] into r4;
    is.eq r3.state 5u8 into r5;
    is.eq r3.player1 r2 into r6;
    and r5 r6 into r7;
    is.eq r3.state 6u8 into r8;
    is.eq r3.player2 r2 into r9;
    and r8 r9 into r10;
    or r7 r10 into r11;
    is.eq r3.state 7u8 into r12;
    is.eq r3.player3 r2 into r13;
    and r12 r13 into r14;
    or r11 r14 into r15;
    is.eq r3.state 11u8 into r16;
    is.eq r3.player1 r2 into r17;
    and r16 r17 into r18;
    or r15 r18 into r19;
    is.eq r3.state 12u8 into r20;
    is.eq r3.player2 r2 into r21;
    and r20 r21 into r22;
    or r19 r22 into r23;
    is.eq r3.state 13u8 into r24;
    is.eq r3.player3 r2 into r25;
    and r24 r25 into r26;
    or r23 r26 into r27;
    is.eq r3.state 17u8 into r28;
    is.eq r3.player1 r2 into r29;
    and r28 r29 into r30;
    or r27 r30 into r31;
    is.eq r3.state 18u8 into r32;
    is.eq r3.player2 r2 into r33;
    and r32 r33 into r34;
    or r31 r34 into r35;
    is.eq r3.state 19u8 into r36;
    is.eq r3.player3 r2 into r37;
    and r36 r37 into r38;
    or r35 r38 into r39;
    is.eq r3.state 23u8 into r40;
    is.eq r3.player1 r2 into r41;
    and r40 r41 into r42;
    or r39 r42 into r43;
    is.eq r3.state 24u8 into r44;
    is.eq r3.player2 r2 into r45;
    and r44 r45 into r46;
    or r43 r46 into r47;
    is.eq r3.state 25u8 into r48;
    is.eq r3.player3 r2 into r49;
    and r48 r49 into r50;
    or r47 r50 into r51;
    assert.eq r51 true;
    is.eq r3.state 5u8 into r52;
    is.eq r3.state 11u8 into r53;
    or r52 r53 into r54;
    is.eq r3.state 17u8 into r55;
    or r54 r55 into r56;
    is.eq r3.state 23u8 into r57;
    or r56 r57 into r58;
    is.eq r3.state 6u8 into r59;
    is.eq r3.state 12u8 into r60;
    or r59 r60 into r61;
    is.eq r3.state 18u8 into r62;
    or r61 r62 into r63;
    is.eq r3.state 24u8 into r64;
    or r63 r64 into r65;
    ternary r65 r4.player2 r4.player3 into r66;
    ternary r65 r4.player2_bet r4.player3_bet into r67;
    ternary r58 r4.player1 r66 into r68;
    ternary r58 r4.player1_bet r67 into r69;
    gte r4.player1_bet r4.player2_bet into r70;
    gte r4.player1_bet r4.player3_bet into r71;
    and r70 r71 into r72;
    gte r4.player2_bet r4.player3_bet into r73;
    ternary r73 r4.player2_bet r4.player3_bet into r74;
    ternary r72 r4.player1_bet r74 into r75;
    is.eq r75 0u16 into r76;
    is.eq r3.last_raise_size 0u16 into r77;
    ternary r77 r3.bb r3.last_raise_size into r78;
    ternary r76 r3.bb r78 into r79;
    add r75 r79 into r80;
    sub r75 r69 into r81;
    is.eq r75 0u16 into r82;
    ternary r82 r3.bb r81 into r83;
    is.eq r1 r68 into r84;
    gte r1 r83 into r85;
    or r84 r85 into r86;
    assert.eq r86 true;
    is.eq r1 r68 into r87;
    is.eq r1 r81 into r88;
    or r87 r88 into r89;
    gte r1 r80 into r90;
    or r89 r90 into r91;
    gt r1 r75 into r92;
    not r91 into r93;
    and r92 r93 into r94;
    gt r1 r75 into r95;
    gte r1 r80 into r96;
    and r95 r96 into r97;
    not r91 into r98;
    and r97 r98 into r99;
    add r69 r1 into r100;
    sub r68 r1 into r101;
    is.eq r101 0u16 into r102;
    is.eq r4.player1 0u16 into r103;
    and r3.players_folded 1u8 into r104;
    is.neq r104 0u8 into r105;
    or r103 r105 into r106;
    and r3.players_out 1u8 into r107;
    is.neq r107 0u8 into r108;
    or r106 r108 into r109;
    is.eq r4.player2 0u16 into r110;
    and r3.players_folded 2u8 into r111;
    is.neq r111 0u8 into r112;
    or r110 r112 into r113;
    and r3.players_out 2u8 into r114;
    is.neq r114 0u8 into r115;
    or r113 r115 into r116;
    is.eq r4.player3 0u16 into r117;
    and r3.players_folded 4u8 into r118;
    is.neq r118 0u8 into r119;
    or r117 r119 into r120;
    and r3.players_out 4u8 into r121;
    is.neq r121 0u8 into r122;
    or r120 r122 into r123;
    not r109 into r124;
    cast r124 into r125 as u8;
    not r116 into r126;
    cast r126 into r127 as u8;
    add r125 r127 into r128;
    not r123 into r129;
    cast r129 into r130 as u8;
    add r128 r130 into r131;
    gt r131 1u8 into r132;
    is.eq r131 1u8 into r133;
    lt r69 r75 into r134;
    and r133 r134 into r135;
    or r132 r135 into r136;
    assert.eq r136 true;
    cast r102 into r137 as u8;
    sub r131 r137 into r138;
    is.eq r4.player1 0u16 into r139;
    lt r4.player1_bet r75 into r140;
    and r139 r140 into r141;
    is.eq r4.player2 0u16 into r142;
    lt r4.player2_bet r75 into r143;
    and r142 r143 into r144;
    or r141 r144 into r145;
    is.eq r4.player3 0u16 into r146;
    lt r4.player3_bet r75 into r147;
    and r146 r147 into r148;
    or r145 r148 into r149;
    lte r138 1u8 into r150;
    gte r100 r75 into r151;
    is.eq r4.player1_bet r75 into r152;
    or r109 r152 into r153;
    is.eq r4.player2_bet r75 into r154;
    or r116 r154 into r155;
    and r153 r155 into r156;
    is.eq r4.player3_bet r75 into r157;
    or r123 r157 into r158;
    and r156 r158 into r159;
    and r151 r159 into r160;
    not r99 into r161;
    is.eq r3.last_bet 0u8 into r162;
    or r161 r162 into r163;
    or r163 r94 into r164;
    not r99 into r165;
    and r149 r165 into r166;
    is.eq r3.state 5u8 into r167;
    is.eq r3.state 11u8 into r168;
    or r167 r168 into r169;
    is.eq r3.state 17u8 into r170;
    or r169 r170 into r171;
    is.eq r3.state 23u8 into r172;
    or r171 r172 into r173;
    and r3.last_bet 1u8 into r174;
    is.neq r174 0u8 into r175;
    and r173 r175 into r176;
    and r166 r176 into r177;
    is.eq r3.state 6u8 into r178;
    is.eq r3.state 12u8 into r179;
    or r178 r179 into r180;
    is.eq r3.state 18u8 into r181;
    or r180 r181 into r182;
    is.eq r3.state 24u8 into r183;
    or r182 r183 into r184;
    and r3.last_bet 2u8 into r185;
    is.neq r185 0u8 into r186;
    and r184 r186 into r187;
    or r177 r187 into r188;
    is.eq r3.state 7u8 into r189;
    is.eq r3.state 13u8 into r190;
    or r189 r190 into r191;
    is.eq r3.state 19u8 into r192;
    or r191 r192 into r193;
    is.eq r3.state 25u8 into r194;
    or r193 r194 into r195;
    and r3.last_bet 4u8 into r196;
    is.neq r196 0u8 into r197;
    and r195 r197 into r198;
    or r188 r198 into r199;
    or r164 r199 into r200;
    and r160 r200 into r201;
    or r150 r201 into r202;
    lte r3.state 7u8 into r203;
    and r3.players_out 1u8 into r204;
    is.neq r204 0u8 into r205;
    ternary r205 9u8 8u8 into r206;
    lte r3.state 13u8 into r207;
    and r3.players_out 1u8 into r208;
    is.neq r208 0u8 into r209;
    ternary r209 15u8 14u8 into r210;
    lte r3.state 19u8 into r211;
    and r3.players_out 1u8 into r212;
    is.neq r212 0u8 into r213;
    ternary r213 21u8 20u8 into r214;
    and r3.players_folded 1u8 into r215;
    is.neq r215 0u8 into r216;
    and r3.players_folded 2u8 into r217;
    is.neq r217 0u8 into r218;
    ternary r218 28u8 27u8 into r219;
    ternary r216 r219 26u8 into r220;
    ternary r211 r214 r220 into r221;
    ternary r207 r210 r221 into r222;
    ternary r203 r206 r222 into r223;
    is.eq r3.state 5u8 into r224;
    ternary r116 7u8 6u8 into r225;
    is.eq r3.state 6u8 into r226;
    ternary r123 5u8 7u8 into r227;
    is.eq r3.state 7u8 into r228;
    ternary r109 6u8 5u8 into r229;
    is.eq r3.state 11u8 into r230;
    ternary r116 13u8 12u8 into r231;
    is.eq r3.state 12u8 into r232;
    ternary r123 11u8 13u8 into r233;
    is.eq r3.state 13u8 into r234;
    ternary r109 12u8 11u8 into r235;
    is.eq r3.state 17u8 into r236;
    ternary r116 19u8 18u8 into r237;
    is.eq r3.state 18u8 into r238;
    ternary r123 17u8 19u8 into r239;
    is.eq r3.state 19u8 into r240;
    ternary r109 18u8 17u8 into r241;
    is.eq r3.state 23u8 into r242;
    ternary r116 25u8 24u8 into r243;
    is.eq r3.state 24u8 into r244;
    ternary r123 23u8 25u8 into r245;
    is.eq r3.state 25u8 into r246;
    ternary r109 24u8 23u8 into r247;
    ternary r246 r247 0u8 into r248;
    ternary r244 r245 r248 into r249;
    ternary r242 r243 r249 into r250;
    ternary r240 r241 r250 into r251;
    ternary r238 r239 r251 into r252;
    ternary r236 r237 r252 into r253;
    ternary r234 r235 r253 into r254;
    ternary r232 r233 r254 into r255;
    ternary r230 r231 r255 into r256;
    ternary r228 r229 r256 into r257;
    ternary r226 r227 r257 into r258;
    ternary r224 r225 r258 into r259;
    ternary r202 r223 r259 into r260;
    gt r100 r75 into r261;
    not r102 into r262;
    and r261 r262 into r263;
    is.eq r3.state 5u8 into r264;
    is.eq r3.state 11u8 into r265;
    or r264 r265 into r266;
    is.eq r3.state 17u8 into r267;
    or r266 r267 into r268;
    is.eq r3.state 23u8 into r269;
    or r268 r269 into r270;
    is.eq r3.state 6u8 into r271;
    is.eq r3.state 12u8 into r272;
    or r271 r272 into r273;
    is.eq r3.state 18u8 into r274;
    or r273 r274 into r275;
    is.eq r3.state 24u8 into r276;
    or r275 r276 into r277;
    ternary r277 2u8 4u8 into r278;
    ternary r270 1u8 r278 into r279;
    ternary r263 r279 r3.last_bet into r280;
    add r4.player1_bet r4.player2_bet into r281;
    add r281 r4.player3_bet into r282;
    add r282 r1 into r283;
    is.eq r3.state 5u8 into r284;
    is.eq r3.state 11u8 into r285;
    or r284 r285 into r286;
    is.eq r3.state 17u8 into r287;
    or r286 r287 into r288;
    is.eq r3.state 23u8 into r289;
    or r288 r289 into r290;
    ternary r290 r101 r4.player1 into r291;
    is.eq r3.state 6u8 into r292;
    is.eq r3.state 12u8 into r293;
    or r292 r293 into r294;
    is.eq r3.state 18u8 into r295;
    or r294 r295 into r296;
    is.eq r3.state 24u8 into r297;
    or r296 r297 into r298;
    ternary r298 r101 r4.player2 into r299;
    is.eq r3.state 7u8 into r300;
    is.eq r3.state 13u8 into r301;
    or r300 r301 into r302;
    is.eq r3.state 19u8 into r303;
    or r302 r303 into r304;
    is.eq r3.state 25u8 into r305;
    or r304 r305 into r306;
    ternary r306 r101 r4.player3 into r307;
    is.eq r3.state 5u8 into r308;
    is.eq r3.state 11u8 into r309;
    or r308 r309 into r310;
    is.eq r3.state 17u8 into r311;
    or r310 r311 into r312;
    is.eq r3.state 23u8 into r313;
    or r312 r313 into r314;
    ternary r314 r100 r4.player1_bet into r315;
    is.eq r3.state 6u8 into r316;
    is.eq r3.state 12u8 into r317;
    or r316 r317 into r318;
    is.eq r3.state 18u8 into r319;
    or r318 r319 into r320;
    is.eq r3.state 24u8 into r321;
    or r320 r321 into r322;
    ternary r322 r100 r4.player2_bet into r323;
    is.eq r3.state 7u8 into r324;
    is.eq r3.state 13u8 into r325;
    or r324 r325 into r326;
    is.eq r3.state 19u8 into r327;
    or r326 r327 into r328;
    is.eq r3.state 25u8 into r329;
    or r328 r329 into r330;
    ternary r330 r100 r4.player3_bet into r331;
    cast r291 r299 r307 r315 r323 r331 into r332 as Chips;
    sub r100 r75 into r333;
    ternary r99 r333 r3.last_raise_size into r334;
    cast r3.player1 r3.player2 r3.player3 r3.buy_in r3.deck r260 r3.dealer_button r3.players_out r3.players_folded r280 r3.sb r3.bb r3.remaining_hands r3.hands_played r334 into r335 as Game;
    set r332 into chips[r0];
    set r335 into games[r0];

function decrypt_hands_p1:
    input r0 as u32.private;
    input r1 as Cards.private;
    input r2 as Keys.record;
    call commutative_encryption.aleo/decrypt_card r2.secret_inv r1.player2[0u32] into r3;
    call commutative_encryption.aleo/decrypt_card r2.secret_inv r1.player2[1u32] into r4;
    cast r3 r4 into r5 as [group; 2u32];
    call commutative_encryption.aleo/decrypt_card r2.secret_inv r1.player3[0u32] into r6;
    call commutative_encryption.aleo/decrypt_card r2.secret_inv r1.player3[1u32] into r7;
    cast r6 r7 into r8 as [group; 2u32];
    cast r1.player1 r5 r8 r1.flop r1.turn r1.river into r9 as Cards;
    async decrypt_hands_p1 r0 r1 r9 self.caller into r10;
    cast r2.owner r2.secret r2.secret_inv into r11 as Keys.record;
    output r11 as Keys.record;
    output r10 as poker.aleo/decrypt_hands_p1.future;

finalize decrypt_hands_p1:
    input r0 as u32.public;
    input r1 as Cards.public;
    input r2 as Cards.public;
    input r3 as address.public;
    get cards[r0] into r4;
    is.eq r1 r4 into r5;
    assert.eq r5 true;
    get games[r0] into r6;
    is.eq r6.state 2u8 into r7;
    assert.eq r7 true;
    is.eq r6.player1 r3 into r8;
    assert.eq r8 true;
    and r6.players_out 2u8 into r9;
    is.neq r9 0u8 into r10;
    branch.eq r10 false to end_then_0_2;
    cast r6.player1 r6.player2 r6.player3 r6.buy_in r6.deck 5u8 r6.dealer_button r6.players_out r6.players_folded r6.last_bet r6.sb r6.bb r6.remaining_hands r6.hands_played r6.last_raise_size into r11 as Game;
    set r2 into cards[r0];
    set r11 into games[r0];
    branch.eq true true to end_otherwise_0_3;
    position end_then_0_2;
    cast r6.player1 r6.player2 r6.player3 r6.buy_in r6.deck 3u8 r6.dealer_button r6.players_out r6.players_folded r6.last_bet r6.sb r6.bb r6.remaining_hands r6.hands_played r6.last_raise_size into r12 as Game;
    set r2 into cards[r0];
    set r12 into games[r0];
    position end_otherwise_0_3;

function decrypt_hands_p2:
    input r0 as u32.private;
    input r1 as Cards.private;
    input r2 as Keys.record;
    call commutative_encryption.aleo/decrypt_card r2.secret_inv r1.player1[0u32] into r3;
    call commutative_encryption.aleo/decrypt_card r2.secret_inv r1.player1[1u32] into r4;
    cast r3 r4 into r5 as [group; 2u32];
    call commutative_encryption.aleo/decrypt_card r2.secret_inv r1.player3[0u32] into r6;
    call commutative_encryption.aleo/decrypt_card r2.secret_inv r1.player3[1u32] into r7;
    cast r6 r7 into r8 as [group; 2u32];
    cast r5 r1.player2 r8 r1.flop r1.turn r1.river into r9 as Cards;
    async decrypt_hands_p2 r0 r1 r9 self.caller into r10;
    cast r2.owner r2.secret r2.secret_inv into r11 as Keys.record;
    output r11 as Keys.record;
    output r10 as poker.aleo/decrypt_hands_p2.future;

finalize decrypt_hands_p2:
    input r0 as u32.public;
    input r1 as Cards.public;
    input r2 as Cards.public;
    input r3 as address.public;
    get cards[r0] into r4;
    is.eq r1 r4 into r5;
    assert.eq r5 true;
    get games[r0] into r6;
    is.eq r6.state 3u8 into r7;
    assert.eq r7 true;
    is.eq r6.player2 r3 into r8;
    assert.eq r8 true;
    set r2 into cards[r0];
    and r6.players_out 4u8 into r9;
    is.neq r9 0u8 into r10;
    and r6.dealer_button 2u8 into r11;
    is.neq r11 0u8 into r12;
    ternary r12 5u8 6u8 into r13;
    ternary r10 r13 4u8 into r14;
    and r6.players_out 4u8 into r15;
    is.neq r15 0u8 into r16;
    and r6.dealer_button 2u8 into r17;
    is.neq r17 0u8 into r18;
    ternary r18 2u8 1u8 into r19;
    ternary r16 r19 r6.last_bet into r20;
    cast r6.player1 r6.player2 r6.player3 r6.buy_in r6.deck r14 r6.dealer_button r6.players_out r6.players_folded r20 r6.sb r6.bb r6.remaining_hands r6.hands_played r6.last_raise_size into r21 as Game;
    set r21 into games[r0];

function decrypt_hands_p3:
    input r0 as u32.private;
    input r1 as Cards.private;
    input r2 as Keys.record;
    call commutative_encryption.aleo/decrypt_card r2.secret_inv r1.player1[0u32] into r3;
    call commutative_encryption.aleo/decrypt_card r2.secret_inv r1.player1[1u32] into r4;
    cast r3 r4 into r5 as [group; 2u32];
    call commutative_encryption.aleo/decrypt_card r2.secret_inv r1.player2[0u32] into r6;
    call commutative_encryption.aleo/decrypt_card r2.secret_inv r1.player2[1u32] into r7;
    cast r6 r7 into r8 as [group; 2u32];
    cast r5 r8 r1.player3 r1.flop r1.turn r1.river into r9 as Cards;
    async decrypt_hands_p3 r0 r1 r9 self.caller into r10;
    cast r2.owner r2.secret r2.secret_inv into r11 as Keys.record;
    output r11 as Keys.record;
    output r10 as poker.aleo/decrypt_hands_p3.future;

finalize decrypt_hands_p3:
    input r0 as u32.public;
    input r1 as Cards.public;
    input r2 as Cards.public;
    input r3 as address.public;
    get cards[r0] into r4;
    is.eq r1 r4 into r5;
    assert.eq r5 true;
    get games[r0] into r6;
    is.eq r6.state 4u8 into r7;
    assert.eq r7 true;
    is.eq r6.player3 r3 into r8;
    assert.eq r8 true;
    set r2 into cards[r0];
    and r6.players_out 1u8 into r9;
    is.neq r9 0u8 into r10;
    and r6.dealer_button 2u8 into r11;
    is.neq r11 0u8 into r12;
    ternary r12 7u8 6u8 into r13;
    and r6.players_out 2u8 into r14;
    is.neq r14 0u8 into r15;
    and r6.dealer_button 1u8 into r16;
    is.neq r16 0u8 into r17;
    ternary r17 7u8 5u8 into r18;
    and r6.players_out 4u8 into r19;
    is.neq r19 0u8 into r20;
    and r6.dealer_button 2u8 into r21;
    is.neq r21 0u8 into r22;
    ternary r22 5u8 6u8 into r23;
    and r6.dealer_button 1u8 into r24;
    is.neq r24 0u8 into r25;
    and r6.dealer_button 2u8 into r26;
    is.neq r26 0u8 into r27;
    ternary r27 5u8 6u8 into r28;
    ternary r25 7u8 r28 into r29;
    ternary r20 r23 r29 into r30;
    ternary r15 r18 r30 into r31;
    ternary r10 r13 r31 into r32;
    and r6.players_folded 1u8 into r33;
    is.neq r33 0u8 into r34;
    and r6.dealer_button 2u8 into r35;
    is.neq r35 0u8 into r36;
    ternary r36 2u8 4u8 into r37;
    and r6.players_folded 2u8 into r38;
    is.neq r38 0u8 into r39;
    and r6.dealer_button 1u8 into r40;
    is.neq r40 0u8 into r41;
    ternary r41 1u8 4u8 into r42;
    and r6.players_folded 4u8 into r43;
    is.neq r43 0u8 into r44;
    and r6.dealer_button 2u8 into r45;
    is.neq r45 0u8 into r46;
    ternary r46 2u8 1u8 into r47;
    and r6.dealer_button 1u8 into r48;
    is.neq r48 0u8 into r49;
    and r6.dealer_button 2u8 into r50;
    is.neq r50 0u8 into r51;
    ternary r51 4u8 1u8 into r52;
    ternary r49 2u8 r52 into r53;
    ternary r44 r47 r53 into r54;
    ternary r39 r42 r54 into r55;
    ternary r34 r37 r55 into r56;
    cast r6.player1 r6.player2 r6.player3 r6.buy_in r6.deck r32 r6.dealer_button r6.players_out r6.players_folded r56 r6.sb r6.bb r6.remaining_hands r6.hands_played r6.last_raise_size into r57 as Game;
    set r57 into games[r0];

constructor:
    assert.eq edition 0u16;
