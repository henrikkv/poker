import zk_deck_shuffle.aleo;
import commutative_encryption.aleo;
program poker.aleo;

record Keys:
    owner as address.private;
    secret as scalar.private;
    secret_inv as scalar.private;

struct Game:
    player1 as address;
    player2 as address;
    player3 as address;
    buy_in as u64;
    state as u8;
    dealer_button as u8;
    players_out as u8;
    players_folded as u8;
    last_bet as u8;
    sb as u16;
    bb as u16;
    remaining_hands as u8;
    hands_played as u8;
    last_raise_size as u16;

struct Chips:
    player1 as u16;
    player2 as u16;
    player3 as u16;
    player1_bet as u16;
    player2_bet as u16;
    player3_bet as u16;

struct Cards:
    player1 as [group; 2u32];
    player2 as [group; 2u32];
    player3 as [group; 2u32];
    flop as [group; 3u32];
    turn as group;
    river as group;

struct RevealedCards:
    player1 as [u8; 2u32];
    player2 as [u8; 2u32];
    player3 as [u8; 2u32];
    flop as [u8; 3u32];
    turn as u8;
    river as u8;

mapping games:
    key as u32.public;
    value as Game.public;

mapping decks:
    key as u32.public;
    value as [[group; 26u32]; 2u32].public;

mapping chips:
    key as u32.public;
    value as Chips.public;

mapping cards:
    key as u32.public;
    value as Cards.public;

mapping revealed_cards:
    key as u32.public;
    value as RevealedCards.public;

function create_game:
    input r0 as u32.private;
    input r1 as i8.private;
    input r2 as i8.private;
    input r3 as i8.private;
    input r4 as scalar.private;
    input r5 as scalar.private;
    call commutative_encryption.aleo/initialize_deck into r6;
    call commutative_encryption.aleo/encrypt_deck r4 r6 into r7;
    call commutative_encryption.aleo/decrypt_card r5 r7[0u32][0u32] into r8;
    assert.eq r8 r6[0u32][0u32];
    cast self.caller r4 r5 into r9 as Keys.record;
    async create_game r0 r7 self.caller into r10;
    output r9 as Keys.record;
    output r10 as poker.aleo/create_game.future;

finalize create_game:
    input r0 as u32.public;
    input r1 as [[group; 26u32]; 2u32].public;
    input r2 as address.public;
    cast r2 aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc 10u64 0u8 1u8 0u8 0u8 0u8 5u16 10u16 10u8 0u8 0u16 into r3 as Game;
    set r3 into games[r0];
    set r1 into decks[r0];

function join_game:
    input r0 as u32.private;
    input r1 as [[group; 26u32]; 2u32].private;
    input r2 as i8.private;
    input r3 as i8.private;
    input r4 as i8.private;
    input r5 as scalar.private;
    input r6 as scalar.private;
    call commutative_encryption.aleo/encrypt_deck r5 r1 into r7;
    call commutative_encryption.aleo/decrypt_card r6 r7[0u32][0u32] into r8;
    assert.eq r8 r1[0u32][0u32];
    cast self.caller r5 r6 into r9 as Keys.record;
    async join_game r0 r1 r7 self.caller into r10;
    output r9 as Keys.record;
    output r10 as poker.aleo/join_game.future;

finalize join_game:
    input r0 as u32.public;
    input r1 as [[group; 26u32]; 2u32].public;
    input r2 as [[group; 26u32]; 2u32].public;
    input r3 as address.public;
    get games[r0] into r4;
    get decks[r0] into r5;
    is.eq r5 r1 into r6;
    assert.eq r6 true;
    is.eq r4.state 0u8 into r7;
    is.eq r4.state 0u8 into r8;
    is.eq r4.state 1u8 into r9;
    or r8 r9 into r10;
    assert.eq r10 true;
    ternary r7 r3 r4.player2 into r11;
    not r7 into r12;
    ternary r12 r3 aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc into r13;
    ternary r7 1u8 2u8 into r14;
    cast r4.player1 r11 r13 r4.buy_in r14 r4.dealer_button 0u8 0u8 0u8 r4.sb r4.bb r4.remaining_hands 0u8 0u16 into r15 as Game;
    set r15 into games[r0];
    set r2 into decks[r0];
    not r7 into r16;
    branch.eq r16 false to end_then_0_0;
    sub 1000u16 r4.sb into r17;
    sub 1000u16 r4.bb into r18;
    cast r17 r18 1000u16 r4.sb r4.bb 0u16 into r19 as Chips;
    cast r2[0u32][0u32] r2[0u32][3u32] into r20 as [group; 2u32];
    cast r2[0u32][1u32] r2[0u32][4u32] into r21 as [group; 2u32];
    cast r2[0u32][2u32] r2[0u32][5u32] into r22 as [group; 2u32];
    cast r2[0u32][7u32] r2[0u32][8u32] r2[0u32][9u32] into r23 as [group; 3u32];
    cast r20 r21 r22 r23 r2[0u32][11u32] r2[0u32][13u32] into r24 as Cards;
    cast 255u8 255u8 into r25 as [u8; 2u32];
    cast 255u8 255u8 into r26 as [u8; 2u32];
    cast 255u8 255u8 into r27 as [u8; 2u32];
    cast 255u8 255u8 255u8 into r28 as [u8; 3u32];
    cast r25 r26 r27 r28 255u8 255u8 into r29 as RevealedCards;
    set r19 into chips[r0];
    set r24 into cards[r0];
    set r29 into revealed_cards[r0];
    branch.eq true true to end_otherwise_0_1;
    position end_then_0_0;
    position end_otherwise_0_1;

function bet:
    input r0 as u32.private;
    input r1 as u16.private;
    async bet r0 r1 self.caller into r2;
    output r2 as poker.aleo/bet.future;

finalize bet:
    input r0 as u32.public;
    input r1 as u16.public;
    input r2 as address.public;
    get games[r0] into r3;
    get chips[r0] into r4;
    is.eq r3.state 5u8 into r5;
    is.eq r3.player1 r2 into r6;
    and r5 r6 into r7;
    is.eq r3.state 6u8 into r8;
    is.eq r3.player2 r2 into r9;
    and r8 r9 into r10;
    or r7 r10 into r11;
    is.eq r3.state 7u8 into r12;
    is.eq r3.player3 r2 into r13;
    and r12 r13 into r14;
    or r11 r14 into r15;
    is.eq r3.state 11u8 into r16;
    is.eq r3.player1 r2 into r17;
    and r16 r17 into r18;
    or r15 r18 into r19;
    is.eq r3.state 12u8 into r20;
    is.eq r3.player2 r2 into r21;
    and r20 r21 into r22;
    or r19 r22 into r23;
    is.eq r3.state 13u8 into r24;
    is.eq r3.player3 r2 into r25;
    and r24 r25 into r26;
    or r23 r26 into r27;
    is.eq r3.state 17u8 into r28;
    is.eq r3.player1 r2 into r29;
    and r28 r29 into r30;
    or r27 r30 into r31;
    is.eq r3.state 18u8 into r32;
    is.eq r3.player2 r2 into r33;
    and r32 r33 into r34;
    or r31 r34 into r35;
    is.eq r3.state 19u8 into r36;
    is.eq r3.player3 r2 into r37;
    and r36 r37 into r38;
    or r35 r38 into r39;
    is.eq r3.state 23u8 into r40;
    is.eq r3.player1 r2 into r41;
    and r40 r41 into r42;
    or r39 r42 into r43;
    is.eq r3.state 24u8 into r44;
    is.eq r3.player2 r2 into r45;
    and r44 r45 into r46;
    or r43 r46 into r47;
    is.eq r3.state 25u8 into r48;
    is.eq r3.player3 r2 into r49;
    and r48 r49 into r50;
    or r47 r50 into r51;
    assert.eq r51 true;
    is.eq r3.state 5u8 into r52;
    is.eq r3.state 11u8 into r53;
    or r52 r53 into r54;
    is.eq r3.state 17u8 into r55;
    or r54 r55 into r56;
    is.eq r3.state 23u8 into r57;
    or r56 r57 into r58;
    is.eq r3.state 6u8 into r59;
    is.eq r3.state 12u8 into r60;
    or r59 r60 into r61;
    is.eq r3.state 18u8 into r62;
    or r61 r62 into r63;
    is.eq r3.state 24u8 into r64;
    or r63 r64 into r65;
    ternary r65 r4.player2 r4.player3 into r66;
    ternary r65 r4.player2_bet r4.player3_bet into r67;
    ternary r58 r4.player1 r66 into r68;
    ternary r58 r4.player1_bet r67 into r69;
    gte r4.player1_bet r4.player2_bet into r70;
    gte r4.player1_bet r4.player3_bet into r71;
    and r70 r71 into r72;
    gte r4.player2_bet r4.player3_bet into r73;
    ternary r73 r4.player2_bet r4.player3_bet into r74;
    ternary r72 r4.player1_bet r74 into r75;
    is.eq r75 0u16 into r76;
    is.eq r3.last_raise_size 0u16 into r77;
    ternary r77 r3.bb r3.last_raise_size into r78;
    ternary r76 r3.bb r78 into r79;
    add r75 r79 into r80;
    sub r75 r69 into r81;
    is.eq r75 0u16 into r82;
    ternary r82 r3.bb r81 into r83;
    is.eq r1 r68 into r84;
    gte r1 r83 into r85;
    or r84 r85 into r86;
    assert.eq r86 true;
    is.eq r1 r68 into r87;
    is.eq r1 r81 into r88;
    or r87 r88 into r89;
    gte r1 r80 into r90;
    or r89 r90 into r91;
    gt r1 r75 into r92;
    not r91 into r93;
    and r92 r93 into r94;
    gt r1 r75 into r95;
    gte r1 r80 into r96;
    and r95 r96 into r97;
    not r91 into r98;
    and r97 r98 into r99;
    add r69 r1 into r100;
    sub r68 r1 into r101;
    is.eq r101 0u16 into r102;
    is.eq r4.player1 0u16 into r103;
    and r3.players_folded 1u8 into r104;
    is.neq r104 0u8 into r105;
    or r103 r105 into r106;
    and r3.players_out 1u8 into r107;
    is.neq r107 0u8 into r108;
    or r106 r108 into r109;
    is.eq r4.player2 0u16 into r110;
    and r3.players_folded 2u8 into r111;
    is.neq r111 0u8 into r112;
    or r110 r112 into r113;
    and r3.players_out 2u8 into r114;
    is.neq r114 0u8 into r115;
    or r113 r115 into r116;
    is.eq r4.player3 0u16 into r117;
    and r3.players_folded 4u8 into r118;
    is.neq r118 0u8 into r119;
    or r117 r119 into r120;
    and r3.players_out 4u8 into r121;
    is.neq r121 0u8 into r122;
    or r120 r122 into r123;
    not r109 into r124;
    cast r124 into r125 as u8;
    not r116 into r126;
    cast r126 into r127 as u8;
    add r125 r127 into r128;
    not r123 into r129;
    cast r129 into r130 as u8;
    add r128 r130 into r131;
    gt r131 1u8 into r132;
    is.eq r131 1u8 into r133;
    lt r69 r75 into r134;
    and r133 r134 into r135;
    or r132 r135 into r136;
    assert.eq r136 true;
    cast r102 into r137 as u8;
    sub r131 r137 into r138;
    is.eq r4.player1 0u16 into r139;
    lt r4.player1_bet r75 into r140;
    and r139 r140 into r141;
    is.eq r4.player2 0u16 into r142;
    lt r4.player2_bet r75 into r143;
    and r142 r143 into r144;
    or r141 r144 into r145;
    is.eq r4.player3 0u16 into r146;
    lt r4.player3_bet r75 into r147;
    and r146 r147 into r148;
    or r145 r148 into r149;
    is.eq r3.state 5u8 into r150;
    is.eq r3.state 11u8 into r151;
    or r150 r151 into r152;
    is.eq r3.state 17u8 into r153;
    or r152 r153 into r154;
    is.eq r3.state 23u8 into r155;
    or r154 r155 into r156;
    and r3.last_bet 1u8 into r157;
    is.neq r157 0u8 into r158;
    and r156 r158 into r159;
    is.eq r3.state 6u8 into r160;
    is.eq r3.state 12u8 into r161;
    or r160 r161 into r162;
    is.eq r3.state 18u8 into r163;
    or r162 r163 into r164;
    is.eq r3.state 24u8 into r165;
    or r164 r165 into r166;
    and r3.last_bet 2u8 into r167;
    is.neq r167 0u8 into r168;
    and r166 r168 into r169;
    or r159 r169 into r170;
    is.eq r3.state 7u8 into r171;
    is.eq r3.state 13u8 into r172;
    or r171 r172 into r173;
    is.eq r3.state 19u8 into r174;
    or r173 r174 into r175;
    is.eq r3.state 25u8 into r176;
    or r175 r176 into r177;
    and r3.last_bet 4u8 into r178;
    is.neq r178 0u8 into r179;
    and r177 r179 into r180;
    or r170 r180 into r181;
    is.eq r3.state 5u8 into r182;
    is.eq r3.state 11u8 into r183;
    or r182 r183 into r184;
    is.eq r3.state 17u8 into r185;
    or r184 r185 into r186;
    is.eq r3.state 23u8 into r187;
    or r186 r187 into r188;
    is.eq r100 r75 into r189;
    is.eq r4.player1_bet r75 into r190;
    ternary r188 r189 r190 into r191;
    or r109 r191 into r192;
    is.eq r3.state 6u8 into r193;
    is.eq r3.state 12u8 into r194;
    or r193 r194 into r195;
    is.eq r3.state 18u8 into r196;
    or r195 r196 into r197;
    is.eq r3.state 24u8 into r198;
    or r197 r198 into r199;
    is.eq r100 r75 into r200;
    is.eq r4.player2_bet r75 into r201;
    ternary r199 r200 r201 into r202;
    or r116 r202 into r203;
    is.eq r3.state 7u8 into r204;
    is.eq r3.state 13u8 into r205;
    or r204 r205 into r206;
    is.eq r3.state 19u8 into r207;
    or r206 r207 into r208;
    is.eq r3.state 25u8 into r209;
    or r208 r209 into r210;
    is.eq r100 r75 into r211;
    is.eq r4.player3_bet r75 into r212;
    ternary r210 r211 r212 into r213;
    or r123 r213 into r214;
    lte r138 1u8 into r215;
    gte r100 r75 into r216;
    and r216 r192 into r217;
    and r217 r203 into r218;
    and r218 r214 into r219;
    is.eq r3.last_bet 0u8 into r220;
    or r181 r220 into r221;
    or r221 r94 into r222;
    not r99 into r223;
    and r149 r223 into r224;
    and r224 r181 into r225;
    or r222 r225 into r226;
    and r219 r226 into r227;
    or r215 r227 into r228;
    lte r3.state 7u8 into r229;
    and r3.players_out 1u8 into r230;
    is.neq r230 0u8 into r231;
    ternary r231 9u8 8u8 into r232;
    lte r3.state 13u8 into r233;
    and r3.players_out 1u8 into r234;
    is.neq r234 0u8 into r235;
    ternary r235 15u8 14u8 into r236;
    lte r3.state 19u8 into r237;
    and r3.players_out 1u8 into r238;
    is.neq r238 0u8 into r239;
    ternary r239 21u8 20u8 into r240;
    and r3.players_folded 1u8 into r241;
    is.neq r241 0u8 into r242;
    and r3.players_folded 2u8 into r243;
    is.neq r243 0u8 into r244;
    ternary r244 28u8 27u8 into r245;
    ternary r242 r245 26u8 into r246;
    ternary r237 r240 r246 into r247;
    ternary r233 r236 r247 into r248;
    ternary r229 r232 r248 into r249;
    is.eq r3.state 5u8 into r250;
    ternary r116 7u8 6u8 into r251;
    is.eq r3.state 6u8 into r252;
    ternary r123 5u8 7u8 into r253;
    is.eq r3.state 7u8 into r254;
    ternary r109 6u8 5u8 into r255;
    is.eq r3.state 11u8 into r256;
    ternary r116 13u8 12u8 into r257;
    is.eq r3.state 12u8 into r258;
    ternary r123 11u8 13u8 into r259;
    is.eq r3.state 13u8 into r260;
    ternary r109 12u8 11u8 into r261;
    is.eq r3.state 17u8 into r262;
    ternary r116 19u8 18u8 into r263;
    is.eq r3.state 18u8 into r264;
    ternary r123 17u8 19u8 into r265;
    is.eq r3.state 19u8 into r266;
    ternary r109 18u8 17u8 into r267;
    is.eq r3.state 23u8 into r268;
    ternary r116 25u8 24u8 into r269;
    is.eq r3.state 24u8 into r270;
    ternary r123 23u8 25u8 into r271;
    is.eq r3.state 25u8 into r272;
    ternary r109 24u8 23u8 into r273;
    ternary r272 r273 0u8 into r274;
    ternary r270 r271 r274 into r275;
    ternary r268 r269 r275 into r276;
    ternary r266 r267 r276 into r277;
    ternary r264 r265 r277 into r278;
    ternary r262 r263 r278 into r279;
    ternary r260 r261 r279 into r280;
    ternary r258 r259 r280 into r281;
    ternary r256 r257 r281 into r282;
    ternary r254 r255 r282 into r283;
    ternary r252 r253 r283 into r284;
    ternary r250 r251 r284 into r285;
    ternary r228 r249 r285 into r286;
    gt r100 r75 into r287;
    not r102 into r288;
    and r287 r288 into r289;
    is.eq r3.state 5u8 into r290;
    is.eq r3.state 11u8 into r291;
    or r290 r291 into r292;
    is.eq r3.state 17u8 into r293;
    or r292 r293 into r294;
    is.eq r3.state 23u8 into r295;
    or r294 r295 into r296;
    is.eq r3.state 6u8 into r297;
    is.eq r3.state 12u8 into r298;
    or r297 r298 into r299;
    is.eq r3.state 18u8 into r300;
    or r299 r300 into r301;
    is.eq r3.state 24u8 into r302;
    or r301 r302 into r303;
    ternary r303 2u8 4u8 into r304;
    ternary r296 1u8 r304 into r305;
    ternary r289 r305 r3.last_bet into r306;
    add r4.player1_bet r4.player2_bet into r307;
    add r307 r4.player3_bet into r308;
    add r308 r1 into r309;
    is.eq r3.state 5u8 into r310;
    is.eq r3.state 11u8 into r311;
    or r310 r311 into r312;
    is.eq r3.state 17u8 into r313;
    or r312 r313 into r314;
    is.eq r3.state 23u8 into r315;
    or r314 r315 into r316;
    ternary r316 r101 r4.player1 into r317;
    is.eq r3.state 6u8 into r318;
    is.eq r3.state 12u8 into r319;
    or r318 r319 into r320;
    is.eq r3.state 18u8 into r321;
    or r320 r321 into r322;
    is.eq r3.state 24u8 into r323;
    or r322 r323 into r324;
    ternary r324 r101 r4.player2 into r325;
    is.eq r3.state 7u8 into r326;
    is.eq r3.state 13u8 into r327;
    or r326 r327 into r328;
    is.eq r3.state 19u8 into r329;
    or r328 r329 into r330;
    is.eq r3.state 25u8 into r331;
    or r330 r331 into r332;
    ternary r332 r101 r4.player3 into r333;
    is.eq r3.state 5u8 into r334;
    is.eq r3.state 11u8 into r335;
    or r334 r335 into r336;
    is.eq r3.state 17u8 into r337;
    or r336 r337 into r338;
    is.eq r3.state 23u8 into r339;
    or r338 r339 into r340;
    ternary r340 r100 r4.player1_bet into r341;
    is.eq r3.state 6u8 into r342;
    is.eq r3.state 12u8 into r343;
    or r342 r343 into r344;
    is.eq r3.state 18u8 into r345;
    or r344 r345 into r346;
    is.eq r3.state 24u8 into r347;
    or r346 r347 into r348;
    ternary r348 r100 r4.player2_bet into r349;
    is.eq r3.state 7u8 into r350;
    is.eq r3.state 13u8 into r351;
    or r350 r351 into r352;
    is.eq r3.state 19u8 into r353;
    or r352 r353 into r354;
    is.eq r3.state 25u8 into r355;
    or r354 r355 into r356;
    ternary r356 r100 r4.player3_bet into r357;
    cast r317 r325 r333 r341 r349 r357 into r358 as Chips;
    sub r100 r75 into r359;
    ternary r99 r359 r3.last_raise_size into r360;
    cast r3.player1 r3.player2 r3.player3 r3.buy_in r286 r3.dealer_button r3.players_out r3.players_folded r306 r3.sb r3.bb r3.remaining_hands r3.hands_played r360 into r361 as Game;
    set r358 into chips[r0];
    set r361 into games[r0];

function decrypt_hands_p1:
    input r0 as u32.private;
    input r1 as Cards.private;
    input r2 as Keys.record;
    call commutative_encryption.aleo/decrypt_card r2.secret_inv r1.player2[0u32] into r3;
    call commutative_encryption.aleo/decrypt_card r2.secret_inv r1.player2[1u32] into r4;
    cast r3 r4 into r5 as [group; 2u32];
    call commutative_encryption.aleo/decrypt_card r2.secret_inv r1.player3[0u32] into r6;
    call commutative_encryption.aleo/decrypt_card r2.secret_inv r1.player3[1u32] into r7;
    cast r6 r7 into r8 as [group; 2u32];
    cast r1.player1 r5 r8 r1.flop r1.turn r1.river into r9 as Cards;
    async decrypt_hands_p1 r0 r1 r9 self.caller into r10;
    cast r2.owner r2.secret r2.secret_inv into r11 as Keys.record;
    output r11 as Keys.record;
    output r10 as poker.aleo/decrypt_hands_p1.future;

finalize decrypt_hands_p1:
    input r0 as u32.public;
    input r1 as Cards.public;
    input r2 as Cards.public;
    input r3 as address.public;
    get cards[r0] into r4;
    is.eq r1 r4 into r5;
    assert.eq r5 true;
    get games[r0] into r6;
    is.eq r6.state 2u8 into r7;
    assert.eq r7 true;
    is.eq r6.player1 r3 into r8;
    assert.eq r8 true;
    and r6.players_out 2u8 into r9;
    is.neq r9 0u8 into r10;
    branch.eq r10 false to end_then_0_2;
    cast r6.player1 r6.player2 r6.player3 r6.buy_in 5u8 r6.dealer_button r6.players_out r6.players_folded r6.last_bet r6.sb r6.bb r6.remaining_hands r6.hands_played r6.last_raise_size into r11 as Game;
    set r2 into cards[r0];
    set r11 into games[r0];
    branch.eq true true to end_otherwise_0_3;
    position end_then_0_2;
    cast r6.player1 r6.player2 r6.player3 r6.buy_in 3u8 r6.dealer_button r6.players_out r6.players_folded r6.last_bet r6.sb r6.bb r6.remaining_hands r6.hands_played r6.last_raise_size into r12 as Game;
    set r2 into cards[r0];
    set r12 into games[r0];
    position end_otherwise_0_3;

function decrypt_hands_p2:
    input r0 as u32.private;
    input r1 as Cards.private;
    input r2 as Keys.record;
    call commutative_encryption.aleo/decrypt_card r2.secret_inv r1.player1[0u32] into r3;
    call commutative_encryption.aleo/decrypt_card r2.secret_inv r1.player1[1u32] into r4;
    cast r3 r4 into r5 as [group; 2u32];
    call commutative_encryption.aleo/decrypt_card r2.secret_inv r1.player3[0u32] into r6;
    call commutative_encryption.aleo/decrypt_card r2.secret_inv r1.player3[1u32] into r7;
    cast r6 r7 into r8 as [group; 2u32];
    cast r5 r1.player2 r8 r1.flop r1.turn r1.river into r9 as Cards;
    async decrypt_hands_p2 r0 r1 r9 self.caller into r10;
    cast r2.owner r2.secret r2.secret_inv into r11 as Keys.record;
    output r11 as Keys.record;
    output r10 as poker.aleo/decrypt_hands_p2.future;

finalize decrypt_hands_p2:
    input r0 as u32.public;
    input r1 as Cards.public;
    input r2 as Cards.public;
    input r3 as address.public;
    get cards[r0] into r4;
    is.eq r1 r4 into r5;
    assert.eq r5 true;
    get games[r0] into r6;
    is.eq r6.state 3u8 into r7;
    assert.eq r7 true;
    is.eq r6.player2 r3 into r8;
    assert.eq r8 true;
    set r2 into cards[r0];
    and r6.players_out 4u8 into r9;
    is.neq r9 0u8 into r10;
    and r6.dealer_button 2u8 into r11;
    is.neq r11 0u8 into r12;
    ternary r12 5u8 6u8 into r13;
    ternary r10 r13 4u8 into r14;
    and r6.players_out 4u8 into r15;
    is.neq r15 0u8 into r16;
    and r6.dealer_button 2u8 into r17;
    is.neq r17 0u8 into r18;
    ternary r18 2u8 1u8 into r19;
    ternary r16 r19 r6.last_bet into r20;
    cast r6.player1 r6.player2 r6.player3 r6.buy_in r14 r6.dealer_button r6.players_out r6.players_folded r20 r6.sb r6.bb r6.remaining_hands r6.hands_played r6.last_raise_size into r21 as Game;
    set r21 into games[r0];

function decrypt_hands_p3:
    input r0 as u32.private;
    input r1 as Cards.private;
    input r2 as Keys.record;
    call commutative_encryption.aleo/decrypt_card r2.secret_inv r1.player1[0u32] into r3;
    call commutative_encryption.aleo/decrypt_card r2.secret_inv r1.player1[1u32] into r4;
    cast r3 r4 into r5 as [group; 2u32];
    call commutative_encryption.aleo/decrypt_card r2.secret_inv r1.player2[0u32] into r6;
    call commutative_encryption.aleo/decrypt_card r2.secret_inv r1.player2[1u32] into r7;
    cast r6 r7 into r8 as [group; 2u32];
    cast r5 r8 r1.player3 r1.flop r1.turn r1.river into r9 as Cards;
    async decrypt_hands_p3 r0 r1 r9 self.caller into r10;
    cast r2.owner r2.secret r2.secret_inv into r11 as Keys.record;
    output r11 as Keys.record;
    output r10 as poker.aleo/decrypt_hands_p3.future;

finalize decrypt_hands_p3:
    input r0 as u32.public;
    input r1 as Cards.public;
    input r2 as Cards.public;
    input r3 as address.public;
    get cards[r0] into r4;
    is.eq r1 r4 into r5;
    assert.eq r5 true;
    get games[r0] into r6;
    is.eq r6.state 4u8 into r7;
    assert.eq r7 true;
    is.eq r6.player3 r3 into r8;
    assert.eq r8 true;
    set r2 into cards[r0];
    and r6.players_out 1u8 into r9;
    is.neq r9 0u8 into r10;
    and r6.dealer_button 2u8 into r11;
    is.neq r11 0u8 into r12;
    ternary r12 7u8 6u8 into r13;
    and r6.players_out 2u8 into r14;
    is.neq r14 0u8 into r15;
    and r6.dealer_button 1u8 into r16;
    is.neq r16 0u8 into r17;
    ternary r17 7u8 5u8 into r18;
    and r6.players_out 4u8 into r19;
    is.neq r19 0u8 into r20;
    and r6.dealer_button 2u8 into r21;
    is.neq r21 0u8 into r22;
    ternary r22 5u8 6u8 into r23;
    and r6.dealer_button 1u8 into r24;
    is.neq r24 0u8 into r25;
    and r6.dealer_button 2u8 into r26;
    is.neq r26 0u8 into r27;
    ternary r27 5u8 6u8 into r28;
    ternary r25 7u8 r28 into r29;
    ternary r20 r23 r29 into r30;
    ternary r15 r18 r30 into r31;
    ternary r10 r13 r31 into r32;
    and r6.players_folded 1u8 into r33;
    is.neq r33 0u8 into r34;
    and r6.dealer_button 2u8 into r35;
    is.neq r35 0u8 into r36;
    ternary r36 2u8 4u8 into r37;
    and r6.players_folded 2u8 into r38;
    is.neq r38 0u8 into r39;
    and r6.dealer_button 1u8 into r40;
    is.neq r40 0u8 into r41;
    ternary r41 1u8 4u8 into r42;
    and r6.players_folded 4u8 into r43;
    is.neq r43 0u8 into r44;
    and r6.dealer_button 2u8 into r45;
    is.neq r45 0u8 into r46;
    ternary r46 2u8 1u8 into r47;
    and r6.dealer_button 1u8 into r48;
    is.neq r48 0u8 into r49;
    and r6.dealer_button 2u8 into r50;
    is.neq r50 0u8 into r51;
    ternary r51 4u8 1u8 into r52;
    ternary r49 2u8 r52 into r53;
    ternary r44 r47 r53 into r54;
    ternary r39 r42 r54 into r55;
    ternary r34 r37 r55 into r56;
    cast r6.player1 r6.player2 r6.player3 r6.buy_in r32 r6.dealer_button r6.players_out r6.players_folded r56 r6.sb r6.bb r6.remaining_hands r6.hands_played r6.last_raise_size into r57 as Game;
    set r57 into games[r0];

function decrypt_flop_p1:
    input r0 as u32.private;
    input r1 as Cards.private;
    input r2 as Keys.record;
    call commutative_encryption.aleo/decrypt_card r2.secret_inv r1.flop[0u32] into r3;
    call commutative_encryption.aleo/decrypt_card r2.secret_inv r1.flop[1u32] into r4;
    call commutative_encryption.aleo/decrypt_card r2.secret_inv r1.flop[2u32] into r5;
    cast r3 r4 r5 into r6 as [group; 3u32];
    cast r1.player1 r1.player2 r1.player3 r6 r1.turn r1.river into r7 as Cards;
    async decrypt_flop_p1 r0 r1 r7 self.caller into r8;
    cast r2.owner r2.secret r2.secret_inv into r9 as Keys.record;
    output r9 as Keys.record;
    output r8 as poker.aleo/decrypt_flop_p1.future;

finalize decrypt_flop_p1:
    input r0 as u32.public;
    input r1 as Cards.public;
    input r2 as Cards.public;
    input r3 as address.public;
    get cards[r0] into r4;
    is.eq r1 r4 into r5;
    assert.eq r5 true;
    get games[r0] into r6;
    is.eq r6.state 8u8 into r7;
    assert.eq r7 true;
    is.eq r6.player1 r3 into r8;
    assert.eq r8 true;
    and r6.players_out 1u8 into r9;
    is.neq r9 0u8 into r10;
    not r10 into r11;
    assert.eq r11 true;
    and r6.players_out 2u8 into r12;
    is.neq r12 0u8 into r13;
    not r13 into r14;
    ternary r14 9u8 10u8 into r15;
    cast r6.player1 r6.player2 r6.player3 r6.buy_in r15 r6.dealer_button r6.players_out r6.players_folded 0u8 r6.sb r6.bb r6.remaining_hands r6.hands_played r6.last_raise_size into r16 as Game;
    set r2 into cards[r0];
    set r16 into games[r0];

function decrypt_flop_p2:
    input r0 as u32.private;
    input r1 as Cards.private;
    input r2 as Keys.record;
    call commutative_encryption.aleo/decrypt_card r2.secret_inv r1.flop[0u32] into r3;
    call commutative_encryption.aleo/decrypt_card r2.secret_inv r1.flop[1u32] into r4;
    call commutative_encryption.aleo/decrypt_card r2.secret_inv r1.flop[2u32] into r5;
    cast r3 r4 r5 into r6 as [group; 3u32];
    cast r1.player1 r1.player2 r1.player3 r6 r1.turn r1.river into r7 as Cards;
    async decrypt_flop_p2 r0 r1 r7 self.caller into r8;
    cast r2.owner r2.secret r2.secret_inv into r9 as Keys.record;
    output r9 as Keys.record;
    output r8 as poker.aleo/decrypt_flop_p2.future;

finalize decrypt_flop_p2:
    input r0 as u32.public;
    input r1 as Cards.public;
    input r2 as Cards.public;
    input r3 as address.public;
    get cards[r0] into r4;
    is.eq r1 r4 into r5;
    assert.eq r5 true;
    get games[r0] into r6;
    is.eq r6.state 9u8 into r7;
    assert.eq r7 true;
    is.eq r6.player2 r3 into r8;
    assert.eq r8 true;
    and r6.players_out 2u8 into r9;
    is.neq r9 0u8 into r10;
    not r10 into r11;
    assert.eq r11 true;
    get chips[r0] into r12;
    is.eq r12.player1 0u16 into r13;
    and r6.players_folded 1u8 into r14;
    is.neq r14 0u8 into r15;
    or r13 r15 into r16;
    is.eq r12.player2 0u16 into r17;
    and r6.players_folded 2u8 into r18;
    is.neq r18 0u8 into r19;
    or r17 r19 into r20;
    is.eq r12.player3 0u16 into r21;
    and r6.players_folded 4u8 into r22;
    is.neq r22 0u8 into r23;
    or r21 r23 into r24;
    not r16 into r25;
    cast r25 into r26 as u8;
    not r20 into r27;
    cast r27 into r28 as u8;
    add r26 r28 into r29;
    not r24 into r30;
    cast r30 into r31 as u8;
    add r29 r31 into r32;
    lte r32 1u8 into r33;
    is.eq r12.player1 0u16 into r34;
    is.eq r12.player2 0u16 into r35;
    and r34 r35 into r36;
    is.eq r12.player3 0u16 into r37;
    and r36 r37 into r38;
    or r33 r38 into r39;
    and r6.players_out 4u8 into r40;
    is.neq r40 0u8 into r41;
    not r41 into r42;
    and r6.dealer_button 1u8 into r43;
    is.neq r43 0u8 into r44;
    not r20 into r45;
    not r24 into r46;
    ternary r46 13u8 11u8 into r47;
    ternary r45 12u8 r47 into r48;
    and r6.dealer_button 2u8 into r49;
    is.neq r49 0u8 into r50;
    not r24 into r51;
    not r16 into r52;
    ternary r52 11u8 12u8 into r53;
    ternary r51 13u8 r53 into r54;
    not r16 into r55;
    not r20 into r56;
    ternary r56 12u8 13u8 into r57;
    ternary r55 11u8 r57 into r58;
    ternary r50 r54 r58 into r59;
    ternary r44 r48 r59 into r60;
    ternary r39 14u8 r60 into r61;
    ternary r42 10u8 r61 into r62;
    cast r6.player1 r6.player2 r6.player3 r6.buy_in r62 r6.dealer_button r6.players_out r6.players_folded 0u8 r6.sb r6.bb r6.remaining_hands r6.hands_played r6.last_raise_size into r63 as Game;
    set r2 into cards[r0];
    set r63 into games[r0];

function decrypt_flop_p3:
    input r0 as u32.private;
    input r1 as Cards.private;
    input r2 as Keys.record;
    call commutative_encryption.aleo/decrypt_card r2.secret_inv r1.flop[0u32] into r3;
    call commutative_encryption.aleo/decrypt_card r2.secret_inv r1.flop[1u32] into r4;
    call commutative_encryption.aleo/decrypt_card r2.secret_inv r1.flop[2u32] into r5;
    cast r3 r4 r5 into r6 as [group; 3u32];
    cast r1.player1 r1.player2 r1.player3 r6 r1.turn r1.river into r7 as Cards;
    call commutative_encryption.aleo/to_u8 r7.flop[0u32] into r8;
    call commutative_encryption.aleo/to_u8 r7.flop[1u32] into r9;
    call commutative_encryption.aleo/to_u8 r7.flop[2u32] into r10;
    cast r8 r9 r10 into r11 as [u8; 3u32];
    async decrypt_flop_p3 r0 r1 r7 self.caller r11 into r12;
    cast r2.owner r2.secret r2.secret_inv into r13 as Keys.record;
    output r13 as Keys.record;
    output r12 as poker.aleo/decrypt_flop_p3.future;

finalize decrypt_flop_p3:
    input r0 as u32.public;
    input r1 as Cards.public;
    input r2 as Cards.public;
    input r3 as address.public;
    input r4 as [u8; 3u32].public;
    get cards[r0] into r5;
    is.eq r1 r5 into r6;
    assert.eq r6 true;
    get games[r0] into r7;
    is.eq r7.state 10u8 into r8;
    assert.eq r8 true;
    is.eq r7.player3 r3 into r9;
    assert.eq r9 true;
    and r7.players_out 4u8 into r10;
    is.neq r10 0u8 into r11;
    not r11 into r12;
    assert.eq r12 true;
    get revealed_cards[r0] into r13;
    cast r13.player1 r13.player2 r13.player3 r4 r13.turn r13.river into r14 as RevealedCards;
    set r14 into revealed_cards[r0];
    get chips[r0] into r15;
    is.eq r15.player1 0u16 into r16;
    and r7.players_folded 1u8 into r17;
    is.neq r17 0u8 into r18;
    or r16 r18 into r19;
    is.eq r15.player2 0u16 into r20;
    and r7.players_folded 2u8 into r21;
    is.neq r21 0u8 into r22;
    or r20 r22 into r23;
    is.eq r15.player3 0u16 into r24;
    and r7.players_folded 4u8 into r25;
    is.neq r25 0u8 into r26;
    or r24 r26 into r27;
    not r19 into r28;
    cast r28 into r29 as u8;
    not r23 into r30;
    cast r30 into r31 as u8;
    add r29 r31 into r32;
    not r27 into r33;
    cast r33 into r34 as u8;
    add r32 r34 into r35;
    lte r35 1u8 into r36;
    is.eq r15.player1 0u16 into r37;
    is.eq r15.player2 0u16 into r38;
    and r37 r38 into r39;
    is.eq r15.player3 0u16 into r40;
    and r39 r40 into r41;
    or r36 r41 into r42;
    and r7.dealer_button 1u8 into r43;
    is.neq r43 0u8 into r44;
    not r23 into r45;
    not r27 into r46;
    ternary r46 13u8 11u8 into r47;
    ternary r45 12u8 r47 into r48;
    and r7.dealer_button 2u8 into r49;
    is.neq r49 0u8 into r50;
    not r27 into r51;
    not r19 into r52;
    ternary r52 11u8 12u8 into r53;
    ternary r51 13u8 r53 into r54;
    not r19 into r55;
    not r23 into r56;
    ternary r56 12u8 13u8 into r57;
    ternary r55 11u8 r57 into r58;
    ternary r50 r54 r58 into r59;
    ternary r44 r48 r59 into r60;
    ternary r42 14u8 r60 into r61;
    and r7.dealer_button 1u8 into r62;
    is.neq r62 0u8 into r63;
    not r19 into r64;
    not r27 into r65;
    ternary r65 4u8 2u8 into r66;
    ternary r64 1u8 r66 into r67;
    and r7.dealer_button 2u8 into r68;
    is.neq r68 0u8 into r69;
    not r23 into r70;
    not r19 into r71;
    ternary r71 1u8 4u8 into r72;
    ternary r70 2u8 r72 into r73;
    not r27 into r74;
    not r23 into r75;
    ternary r75 2u8 1u8 into r76;
    ternary r74 4u8 r76 into r77;
    ternary r69 r73 r77 into r78;
    ternary r63 r67 r78 into r79;
    cast r7.player1 r7.player2 r7.player3 r7.buy_in r61 r7.dealer_button r7.players_out r7.players_folded r79 r7.sb r7.bb r7.remaining_hands r7.hands_played 0u16 into r80 as Game;
    set r2 into cards[r0];
    set r80 into games[r0];

function fold:
    input r0 as u32.private;
    async fold r0 self.caller into r1;
    output r1 as poker.aleo/fold.future;

finalize fold:
    input r0 as u32.public;
    input r1 as address.public;
    get games[r0] into r2;
    get chips[r0] into r3;
    gte r2.state 5u8 into r4;
    lte r2.state 7u8 into r5;
    and r4 r5 into r6;
    gte r2.state 11u8 into r7;
    lte r2.state 13u8 into r8;
    and r7 r8 into r9;
    or r6 r9 into r10;
    gte r2.state 17u8 into r11;
    lte r2.state 19u8 into r12;
    and r11 r12 into r13;
    or r10 r13 into r14;
    gte r2.state 23u8 into r15;
    lte r2.state 25u8 into r16;
    and r15 r16 into r17;
    or r14 r17 into r18;
    assert.eq r18 true;
    is.eq r2.player1 r1 into r19;
    is.eq r2.player2 r1 into r20;
    is.eq r2.player3 r1 into r21;
    or r19 r20 into r22;
    or r22 r21 into r23;
    assert.eq r23 true;
    ternary r20 2u8 4u8 into r24;
    ternary r19 1u8 r24 into r25;
    or r2.players_folded r25 into r26;
    and r26 1u8 into r27;
    is.neq r27 0u8 into r28;
    ternary r28 1u8 0u8 into r29;
    sub 3u8 r29 into r30;
    and r26 2u8 into r31;
    is.neq r31 0u8 into r32;
    ternary r32 1u8 0u8 into r33;
    sub r30 r33 into r34;
    and r26 4u8 into r35;
    is.neq r35 0u8 into r36;
    ternary r36 1u8 0u8 into r37;
    sub r34 r37 into r38;
    is.eq r38 1u8 into r39;
    branch.eq r39 false to end_then_0_4;
    add r3.player1_bet r3.player2_bet into r40;
    add r40 r3.player3_bet into r41;
    and r26 1u8 into r42;
    is.neq r42 0u8 into r43;
    not r43 into r44;
    add r3.player1 r41 into r45;
    ternary r44 r45 r3.player1 into r46;
    and r26 2u8 into r47;
    is.neq r47 0u8 into r48;
    not r48 into r49;
    add r3.player2 r41 into r50;
    ternary r49 r50 r3.player2 into r51;
    and r26 4u8 into r52;
    is.neq r52 0u8 into r53;
    not r53 into r54;
    add r3.player3 r41 into r55;
    ternary r54 r55 r3.player3 into r56;
    cast r46 r51 r56 0u16 0u16 0u16 into r57 as Chips;
    and r2.players_out 1u8 into r58;
    is.neq r58 0u8 into r59;
    not r59 into r60;
    and r2.players_out 2u8 into r61;
    is.neq r61 0u8 into r62;
    not r62 into r63;
    ternary r63 30u8 31u8 into r64;
    ternary r60 29u8 r64 into r65;
    cast r2.player1 r2.player2 r2.player3 r2.buy_in r65 r2.dealer_button r2.players_out r26 0u8 r2.sb r2.bb r2.remaining_hands r2.hands_played 0u16 into r66 as Game;
    set r57 into chips[r0];
    set r66 into games[r0];
    branch.eq true true to end_otherwise_0_5;
    position end_then_0_4;
    position end_otherwise_0_5;
    gte r3.player1_bet r3.player2_bet into r67;
    gte r3.player1_bet r3.player3_bet into r68;
    and r67 r68 into r69;
    gte r3.player2_bet r3.player3_bet into r70;
    ternary r70 r3.player2_bet r3.player3_bet into r71;
    ternary r69 r3.player1_bet r71 into r72;
    and r26 1u8 into r73;
    is.neq r73 0u8 into r74;
    is.eq r3.player1_bet r72 into r75;
    or r74 r75 into r76;
    and r26 2u8 into r77;
    is.neq r77 0u8 into r78;
    is.eq r3.player2_bet r72 into r79;
    or r78 r79 into r80;
    and r76 r80 into r81;
    and r26 4u8 into r82;
    is.neq r82 0u8 into r83;
    is.eq r3.player3_bet r72 into r84;
    or r83 r84 into r85;
    and r81 r85 into r86;
    lte r2.state 7u8 into r87;
    lte r2.state 13u8 into r88;
    lte r2.state 19u8 into r89;
    ternary r89 17u8 23u8 into r90;
    ternary r88 11u8 r90 into r91;
    ternary r87 5u8 r91 into r92;
    lte r2.state 7u8 into r93;
    and r2.players_out 1u8 into r94;
    is.neq r94 0u8 into r95;
    ternary r95 9u8 8u8 into r96;
    lte r2.state 13u8 into r97;
    and r2.players_out 1u8 into r98;
    is.neq r98 0u8 into r99;
    ternary r99 15u8 14u8 into r100;
    lte r2.state 19u8 into r101;
    and r2.players_out 1u8 into r102;
    is.neq r102 0u8 into r103;
    ternary r103 21u8 20u8 into r104;
    and r2.players_out 1u8 into r105;
    is.neq r105 0u8 into r106;
    ternary r106 27u8 26u8 into r107;
    ternary r101 r104 r107 into r108;
    ternary r97 r100 r108 into r109;
    ternary r93 r96 r109 into r110;
    and r26 2u8 into r111;
    is.neq r111 0u8 into r112;
    add r92 2u8 into r113;
    add r92 1u8 into r114;
    ternary r112 r113 r114 into r115;
    and r26 4u8 into r116;
    is.neq r116 0u8 into r117;
    add r92 2u8 into r118;
    ternary r117 r92 r118 into r119;
    and r26 1u8 into r120;
    is.neq r120 0u8 into r121;
    add r92 1u8 into r122;
    ternary r121 r122 r92 into r123;
    ternary r20 r119 r123 into r124;
    ternary r19 r115 r124 into r125;
    ternary r86 r110 r125 into r126;
    ternary r86 0u8 r2.last_bet into r127;
    ternary r86 0u16 r2.last_raise_size into r128;
    cast r2.player1 r2.player2 r2.player3 r2.buy_in r126 r2.dealer_button r2.players_out r26 r127 r2.sb r2.bb r2.remaining_hands r2.hands_played r128 into r129 as Game;
    set r129 into games[r0];

function decrypt_turn_p1:
    input r0 as u32.private;
    input r1 as Cards.private;
    input r2 as Keys.record;
    call commutative_encryption.aleo/decrypt_card r2.secret_inv r1.turn into r3;
    cast r1.player1 r1.player2 r1.player3 r1.flop r3 r1.river into r4 as Cards;
    async decrypt_turn_p1 r0 r1 r4 self.caller into r5;
    cast r2.owner r2.secret r2.secret_inv into r6 as Keys.record;
    output r6 as Keys.record;
    output r5 as poker.aleo/decrypt_turn_p1.future;

finalize decrypt_turn_p1:
    input r0 as u32.public;
    input r1 as Cards.public;
    input r2 as Cards.public;
    input r3 as address.public;
    get cards[r0] into r4;
    is.eq r1 r4 into r5;
    assert.eq r5 true;
    get games[r0] into r6;
    is.eq r6.state 14u8 into r7;
    assert.eq r7 true;
    is.eq r6.player1 r3 into r8;
    assert.eq r8 true;
    and r6.players_out 1u8 into r9;
    is.neq r9 0u8 into r10;
    not r10 into r11;
    assert.eq r11 true;
    and r6.players_out 2u8 into r12;
    is.neq r12 0u8 into r13;
    not r13 into r14;
    ternary r14 15u8 16u8 into r15;
    cast r6.player1 r6.player2 r6.player3 r6.buy_in r15 r6.dealer_button r6.players_out r6.players_folded 0u8 r6.sb r6.bb r6.remaining_hands r6.hands_played r6.last_raise_size into r16 as Game;
    set r2 into cards[r0];
    set r16 into games[r0];

function decrypt_turn_p2:
    input r0 as u32.private;
    input r1 as Cards.private;
    input r2 as Keys.record;
    call commutative_encryption.aleo/decrypt_card r2.secret_inv r1.turn into r3;
    cast r1.player1 r1.player2 r1.player3 r1.flop r3 r1.river into r4 as Cards;
    async decrypt_turn_p2 r0 r1 r4 self.caller into r5;
    cast r2.owner r2.secret r2.secret_inv into r6 as Keys.record;
    output r6 as Keys.record;
    output r5 as poker.aleo/decrypt_turn_p2.future;

finalize decrypt_turn_p2:
    input r0 as u32.public;
    input r1 as Cards.public;
    input r2 as Cards.public;
    input r3 as address.public;
    get cards[r0] into r4;
    is.eq r1 r4 into r5;
    assert.eq r5 true;
    get games[r0] into r6;
    is.eq r6.state 15u8 into r7;
    assert.eq r7 true;
    is.eq r6.player2 r3 into r8;
    assert.eq r8 true;
    and r6.players_out 2u8 into r9;
    is.neq r9 0u8 into r10;
    not r10 into r11;
    assert.eq r11 true;
    get chips[r0] into r12;
    is.eq r12.player1 0u16 into r13;
    and r6.players_folded 1u8 into r14;
    is.neq r14 0u8 into r15;
    or r13 r15 into r16;
    is.eq r12.player2 0u16 into r17;
    and r6.players_folded 2u8 into r18;
    is.neq r18 0u8 into r19;
    or r17 r19 into r20;
    is.eq r12.player3 0u16 into r21;
    and r6.players_folded 4u8 into r22;
    is.neq r22 0u8 into r23;
    or r21 r23 into r24;
    not r16 into r25;
    cast r25 into r26 as u8;
    not r20 into r27;
    cast r27 into r28 as u8;
    add r26 r28 into r29;
    not r24 into r30;
    cast r30 into r31 as u8;
    add r29 r31 into r32;
    lte r32 1u8 into r33;
    is.eq r12.player1 0u16 into r34;
    is.eq r12.player2 0u16 into r35;
    and r34 r35 into r36;
    is.eq r12.player3 0u16 into r37;
    and r36 r37 into r38;
    or r33 r38 into r39;
    and r6.players_out 4u8 into r40;
    is.neq r40 0u8 into r41;
    not r41 into r42;
    and r6.dealer_button 1u8 into r43;
    is.neq r43 0u8 into r44;
    not r20 into r45;
    not r24 into r46;
    ternary r46 19u8 17u8 into r47;
    ternary r45 18u8 r47 into r48;
    and r6.dealer_button 2u8 into r49;
    is.neq r49 0u8 into r50;
    not r24 into r51;
    not r16 into r52;
    ternary r52 17u8 18u8 into r53;
    ternary r51 19u8 r53 into r54;
    not r16 into r55;
    not r20 into r56;
    ternary r56 18u8 19u8 into r57;
    ternary r55 17u8 r57 into r58;
    ternary r50 r54 r58 into r59;
    ternary r44 r48 r59 into r60;
    ternary r39 20u8 r60 into r61;
    ternary r42 16u8 r61 into r62;
    cast r6.player1 r6.player2 r6.player3 r6.buy_in r62 r6.dealer_button r6.players_out r6.players_folded 0u8 r6.sb r6.bb r6.remaining_hands r6.hands_played r6.last_raise_size into r63 as Game;
    set r2 into cards[r0];
    set r63 into games[r0];

function decrypt_turn_p3:
    input r0 as u32.private;
    input r1 as Cards.private;
    input r2 as Keys.record;
    call commutative_encryption.aleo/decrypt_card r2.secret_inv r1.turn into r3;
    cast r1.player1 r1.player2 r1.player3 r1.flop r3 r1.river into r4 as Cards;
    call commutative_encryption.aleo/to_u8 r4.turn into r5;
    async decrypt_turn_p3 r0 r1 r4 self.caller r5 into r6;
    cast r2.owner r2.secret r2.secret_inv into r7 as Keys.record;
    output r7 as Keys.record;
    output r6 as poker.aleo/decrypt_turn_p3.future;

finalize decrypt_turn_p3:
    input r0 as u32.public;
    input r1 as Cards.public;
    input r2 as Cards.public;
    input r3 as address.public;
    input r4 as u8.public;
    get cards[r0] into r5;
    is.eq r1 r5 into r6;
    assert.eq r6 true;
    get games[r0] into r7;
    is.eq r7.state 16u8 into r8;
    assert.eq r8 true;
    is.eq r7.player3 r3 into r9;
    assert.eq r9 true;
    and r7.players_out 4u8 into r10;
    is.neq r10 0u8 into r11;
    not r11 into r12;
    assert.eq r12 true;
    get revealed_cards[r0] into r13;
    cast r13.player1 r13.player2 r13.player3 r13.flop r4 r13.river into r14 as RevealedCards;
    set r14 into revealed_cards[r0];
    get chips[r0] into r15;
    is.eq r15.player1 0u16 into r16;
    and r7.players_folded 1u8 into r17;
    is.neq r17 0u8 into r18;
    or r16 r18 into r19;
    is.eq r15.player2 0u16 into r20;
    and r7.players_folded 2u8 into r21;
    is.neq r21 0u8 into r22;
    or r20 r22 into r23;
    is.eq r15.player3 0u16 into r24;
    and r7.players_folded 4u8 into r25;
    is.neq r25 0u8 into r26;
    or r24 r26 into r27;
    not r19 into r28;
    cast r28 into r29 as u8;
    not r23 into r30;
    cast r30 into r31 as u8;
    add r29 r31 into r32;
    not r27 into r33;
    cast r33 into r34 as u8;
    add r32 r34 into r35;
    lte r35 1u8 into r36;
    is.eq r15.player1 0u16 into r37;
    is.eq r15.player2 0u16 into r38;
    and r37 r38 into r39;
    is.eq r15.player3 0u16 into r40;
    and r39 r40 into r41;
    or r36 r41 into r42;
    and r7.dealer_button 1u8 into r43;
    is.neq r43 0u8 into r44;
    not r23 into r45;
    not r27 into r46;
    ternary r46 19u8 17u8 into r47;
    ternary r45 18u8 r47 into r48;
    and r7.dealer_button 2u8 into r49;
    is.neq r49 0u8 into r50;
    not r27 into r51;
    not r19 into r52;
    ternary r52 17u8 18u8 into r53;
    ternary r51 19u8 r53 into r54;
    not r19 into r55;
    not r23 into r56;
    ternary r56 18u8 19u8 into r57;
    ternary r55 17u8 r57 into r58;
    ternary r50 r54 r58 into r59;
    ternary r44 r48 r59 into r60;
    ternary r42 20u8 r60 into r61;
    and r7.dealer_button 1u8 into r62;
    is.neq r62 0u8 into r63;
    not r19 into r64;
    not r27 into r65;
    ternary r65 4u8 2u8 into r66;
    ternary r64 1u8 r66 into r67;
    and r7.dealer_button 2u8 into r68;
    is.neq r68 0u8 into r69;
    not r23 into r70;
    not r19 into r71;
    ternary r71 1u8 4u8 into r72;
    ternary r70 2u8 r72 into r73;
    not r27 into r74;
    not r23 into r75;
    ternary r75 2u8 1u8 into r76;
    ternary r74 4u8 r76 into r77;
    ternary r69 r73 r77 into r78;
    ternary r63 r67 r78 into r79;
    cast r7.player1 r7.player2 r7.player3 r7.buy_in r61 r7.dealer_button r7.players_out r7.players_folded r79 r7.sb r7.bb r7.remaining_hands r7.hands_played 0u16 into r80 as Game;
    set r2 into cards[r0];
    set r80 into games[r0];

function decrypt_river_p1:
    input r0 as u32.private;
    input r1 as Cards.private;
    input r2 as Keys.record;
    call commutative_encryption.aleo/decrypt_card r2.secret_inv r1.river into r3;
    cast r1.player1 r1.player2 r1.player3 r1.flop r1.turn r3 into r4 as Cards;
    async decrypt_river_p1 r0 r1 r4 self.caller into r5;
    cast r2.owner r2.secret r2.secret_inv into r6 as Keys.record;
    output r6 as Keys.record;
    output r5 as poker.aleo/decrypt_river_p1.future;

finalize decrypt_river_p1:
    input r0 as u32.public;
    input r1 as Cards.public;
    input r2 as Cards.public;
    input r3 as address.public;
    get cards[r0] into r4;
    is.eq r1 r4 into r5;
    assert.eq r5 true;
    get games[r0] into r6;
    is.eq r6.state 20u8 into r7;
    assert.eq r7 true;
    is.eq r6.player1 r3 into r8;
    assert.eq r8 true;
    and r6.players_out 1u8 into r9;
    is.neq r9 0u8 into r10;
    not r10 into r11;
    assert.eq r11 true;
    and r6.players_out 2u8 into r12;
    is.neq r12 0u8 into r13;
    not r13 into r14;
    ternary r14 21u8 22u8 into r15;
    cast r6.player1 r6.player2 r6.player3 r6.buy_in r15 r6.dealer_button r6.players_out r6.players_folded 0u8 r6.sb r6.bb r6.remaining_hands r6.hands_played r6.last_raise_size into r16 as Game;
    set r2 into cards[r0];
    set r16 into games[r0];

function decrypt_river_p2:
    input r0 as u32.private;
    input r1 as Cards.private;
    input r2 as Keys.record;
    call commutative_encryption.aleo/decrypt_card r2.secret_inv r1.river into r3;
    cast r1.player1 r1.player2 r1.player3 r1.flop r1.turn r3 into r4 as Cards;
    async decrypt_river_p2 r0 r1 r4 self.caller into r5;
    cast r2.owner r2.secret r2.secret_inv into r6 as Keys.record;
    output r6 as Keys.record;
    output r5 as poker.aleo/decrypt_river_p2.future;

finalize decrypt_river_p2:
    input r0 as u32.public;
    input r1 as Cards.public;
    input r2 as Cards.public;
    input r3 as address.public;
    get cards[r0] into r4;
    is.eq r1 r4 into r5;
    assert.eq r5 true;
    get games[r0] into r6;
    is.eq r6.state 21u8 into r7;
    assert.eq r7 true;
    is.eq r6.player2 r3 into r8;
    assert.eq r8 true;
    and r6.players_out 2u8 into r9;
    is.neq r9 0u8 into r10;
    not r10 into r11;
    assert.eq r11 true;
    get chips[r0] into r12;
    is.eq r12.player1 0u16 into r13;
    and r6.players_folded 1u8 into r14;
    is.neq r14 0u8 into r15;
    or r13 r15 into r16;
    is.eq r12.player2 0u16 into r17;
    and r6.players_folded 2u8 into r18;
    is.neq r18 0u8 into r19;
    or r17 r19 into r20;
    is.eq r12.player3 0u16 into r21;
    and r6.players_folded 4u8 into r22;
    is.neq r22 0u8 into r23;
    or r21 r23 into r24;
    not r16 into r25;
    cast r25 into r26 as u8;
    not r20 into r27;
    cast r27 into r28 as u8;
    add r26 r28 into r29;
    not r24 into r30;
    cast r30 into r31 as u8;
    add r29 r31 into r32;
    lte r32 1u8 into r33;
    is.eq r12.player1 0u16 into r34;
    is.eq r12.player2 0u16 into r35;
    and r34 r35 into r36;
    is.eq r12.player3 0u16 into r37;
    and r36 r37 into r38;
    or r33 r38 into r39;
    and r6.players_out 4u8 into r40;
    is.neq r40 0u8 into r41;
    not r41 into r42;
    and r6.dealer_button 1u8 into r43;
    is.neq r43 0u8 into r44;
    not r20 into r45;
    not r24 into r46;
    ternary r46 25u8 23u8 into r47;
    ternary r45 24u8 r47 into r48;
    and r6.dealer_button 2u8 into r49;
    is.neq r49 0u8 into r50;
    not r24 into r51;
    not r16 into r52;
    ternary r52 23u8 24u8 into r53;
    ternary r51 25u8 r53 into r54;
    not r16 into r55;
    not r20 into r56;
    ternary r56 24u8 25u8 into r57;
    ternary r55 23u8 r57 into r58;
    ternary r50 r54 r58 into r59;
    ternary r44 r48 r59 into r60;
    ternary r39 26u8 r60 into r61;
    ternary r42 22u8 r61 into r62;
    cast r6.player1 r6.player2 r6.player3 r6.buy_in r62 r6.dealer_button r6.players_out r6.players_folded 0u8 r6.sb r6.bb r6.remaining_hands r6.hands_played r6.last_raise_size into r63 as Game;
    set r2 into cards[r0];
    set r63 into games[r0];

function decrypt_river_p3:
    input r0 as u32.private;
    input r1 as Cards.private;
    input r2 as Keys.record;
    call commutative_encryption.aleo/decrypt_card r2.secret_inv r1.river into r3;
    cast r1.player1 r1.player2 r1.player3 r1.flop r1.turn r3 into r4 as Cards;
    call commutative_encryption.aleo/to_u8 r4.river into r5;
    async decrypt_river_p3 r0 r1 r4 self.caller r5 into r6;
    cast r2.owner r2.secret r2.secret_inv into r7 as Keys.record;
    output r7 as Keys.record;
    output r6 as poker.aleo/decrypt_river_p3.future;

finalize decrypt_river_p3:
    input r0 as u32.public;
    input r1 as Cards.public;
    input r2 as Cards.public;
    input r3 as address.public;
    input r4 as u8.public;
    get cards[r0] into r5;
    is.eq r1 r5 into r6;
    assert.eq r6 true;
    get games[r0] into r7;
    is.eq r7.state 22u8 into r8;
    assert.eq r8 true;
    is.eq r7.player3 r3 into r9;
    assert.eq r9 true;
    and r7.players_out 4u8 into r10;
    is.neq r10 0u8 into r11;
    not r11 into r12;
    assert.eq r12 true;
    get revealed_cards[r0] into r13;
    cast r13.player1 r13.player2 r13.player3 r13.flop r13.turn r4 into r14 as RevealedCards;
    set r14 into revealed_cards[r0];
    get chips[r0] into r15;
    is.eq r15.player1 0u16 into r16;
    and r7.players_folded 1u8 into r17;
    is.neq r17 0u8 into r18;
    or r16 r18 into r19;
    is.eq r15.player2 0u16 into r20;
    and r7.players_folded 2u8 into r21;
    is.neq r21 0u8 into r22;
    or r20 r22 into r23;
    is.eq r15.player3 0u16 into r24;
    and r7.players_folded 4u8 into r25;
    is.neq r25 0u8 into r26;
    or r24 r26 into r27;
    not r19 into r28;
    cast r28 into r29 as u8;
    not r23 into r30;
    cast r30 into r31 as u8;
    add r29 r31 into r32;
    not r27 into r33;
    cast r33 into r34 as u8;
    add r32 r34 into r35;
    lte r35 1u8 into r36;
    is.eq r15.player1 0u16 into r37;
    is.eq r15.player2 0u16 into r38;
    and r37 r38 into r39;
    is.eq r15.player3 0u16 into r40;
    and r39 r40 into r41;
    or r36 r41 into r42;
    and r7.dealer_button 1u8 into r43;
    is.neq r43 0u8 into r44;
    not r23 into r45;
    not r27 into r46;
    ternary r46 25u8 23u8 into r47;
    ternary r45 24u8 r47 into r48;
    and r7.dealer_button 2u8 into r49;
    is.neq r49 0u8 into r50;
    not r27 into r51;
    not r19 into r52;
    ternary r52 23u8 24u8 into r53;
    ternary r51 25u8 r53 into r54;
    not r19 into r55;
    not r23 into r56;
    ternary r56 24u8 25u8 into r57;
    ternary r55 23u8 r57 into r58;
    ternary r50 r54 r58 into r59;
    ternary r44 r48 r59 into r60;
    ternary r42 26u8 r60 into r61;
    and r7.dealer_button 1u8 into r62;
    is.neq r62 0u8 into r63;
    not r19 into r64;
    not r27 into r65;
    ternary r65 4u8 2u8 into r66;
    ternary r64 1u8 r66 into r67;
    and r7.dealer_button 2u8 into r68;
    is.neq r68 0u8 into r69;
    not r23 into r70;
    not r19 into r71;
    ternary r71 1u8 4u8 into r72;
    ternary r70 2u8 r72 into r73;
    not r27 into r74;
    not r23 into r75;
    ternary r75 2u8 1u8 into r76;
    ternary r74 4u8 r76 into r77;
    ternary r69 r73 r77 into r78;
    ternary r63 r67 r78 into r79;
    cast r7.player1 r7.player2 r7.player3 r7.buy_in r61 r7.dealer_button r7.players_out r7.players_folded r79 r7.sb r7.bb r7.remaining_hands r7.hands_played 0u16 into r80 as Game;
    set r2 into cards[r0];
    set r80 into games[r0];

function showdown_p1:
    input r0 as u32.private;
    input r1 as Cards.private;
    input r2 as Keys.record;
    call commutative_encryption.aleo/decrypt_card r2.secret_inv r1.player1[0u32] into r3;
    call commutative_encryption.aleo/decrypt_card r2.secret_inv r1.player1[1u32] into r4;
    cast r3 r4 into r5 as [group; 2u32];
    cast r5 r1.player2 r1.player3 r1.flop r1.turn r1.river into r6 as Cards;
    call commutative_encryption.aleo/to_u8 r6.player1[0u32] into r7;
    call commutative_encryption.aleo/to_u8 r6.player1[1u32] into r8;
    cast r7 r8 into r9 as [u8; 2u32];
    async showdown_p1 r0 r1 r6 self.caller r9 into r10;
    cast r2.owner r2.secret r2.secret_inv into r11 as Keys.record;
    output r11 as Keys.record;
    output r10 as poker.aleo/showdown_p1.future;

finalize showdown_p1:
    input r0 as u32.public;
    input r1 as Cards.public;
    input r2 as Cards.public;
    input r3 as address.public;
    input r4 as [u8; 2u32].public;
    get cards[r0] into r5;
    is.eq r1 r5 into r6;
    assert.eq r6 true;
    get games[r0] into r7;
    is.eq r7.state 26u8 into r8;
    assert.eq r8 true;
    is.eq r7.player1 r3 into r9;
    assert.eq r9 true;
    get revealed_cards[r0] into r10;
    cast r4 r10.player2 r10.player3 r10.flop r10.turn r10.river into r11 as RevealedCards;
    set r11 into revealed_cards[r0];
    and r7.players_out 2u8 into r12;
    is.neq r12 0u8 into r13;
    not r13 into r14;
    ternary r14 27u8 28u8 into r15;
    cast r7.player1 r7.player2 r7.player3 r7.buy_in r15 r7.dealer_button r7.players_out r7.players_folded r7.last_bet r7.sb r7.bb r7.remaining_hands r7.hands_played r7.last_raise_size into r16 as Game;
    set r2 into cards[r0];
    set r16 into games[r0];

function showdown_p2:
    input r0 as u32.private;
    input r1 as Cards.private;
    input r2 as Keys.record;
    call commutative_encryption.aleo/decrypt_card r2.secret_inv r1.player2[0u32] into r3;
    call commutative_encryption.aleo/decrypt_card r2.secret_inv r1.player2[1u32] into r4;
    cast r3 r4 into r5 as [group; 2u32];
    cast r1.player1 r5 r1.player3 r1.flop r1.turn r1.river into r6 as Cards;
    call commutative_encryption.aleo/to_u8 r6.player1[0u32] into r7;
    call commutative_encryption.aleo/to_u8 r6.player1[1u32] into r8;
    cast r7 r8 into r9 as [u8; 2u32];
    call commutative_encryption.aleo/to_u8 r6.player2[0u32] into r10;
    call commutative_encryption.aleo/to_u8 r6.player2[1u32] into r11;
    cast r10 r11 into r12 as [u8; 2u32];
    async showdown_p2 r0 r1 r6 self.caller r9 r12 into r13;
    cast r2.owner r2.secret r2.secret_inv into r14 as Keys.record;
    output r14 as Keys.record;
    output r13 as poker.aleo/showdown_p2.future;

finalize showdown_p2:
    input r0 as u32.public;
    input r1 as Cards.public;
    input r2 as Cards.public;
    input r3 as address.public;
    input r4 as [u8; 2u32].public;
    input r5 as [u8; 2u32].public;
    get cards[r0] into r6;
    is.eq r1 r6 into r7;
    assert.eq r7 true;
    get games[r0] into r8;
    is.eq r8.state 27u8 into r9;
    assert.eq r9 true;
    is.eq r8.player2 r3 into r10;
    assert.eq r10 true;
    get revealed_cards[r0] into r11;
    cast r4 r5 r11.player3 r11.flop r11.turn r11.river into r12 as RevealedCards;
    set r12 into revealed_cards[r0];
    and r8.players_out 4u8 into r13;
    is.neq r13 0u8 into r14;
    and r8.players_folded 4u8 into r15;
    is.neq r15 0u8 into r16;
    or r14 r16 into r17;
    branch.eq r17 false to end_then_0_6;
    get chips[r0] into r18;
    add r18.player1_bet r18.player2_bet into r19;
    add r19 r18.player3_bet into r20;
    is.eq 1u8 1u8 into r21;
    add r18.player1 r20 into r22;
    ternary r21 r22 r18.player1 into r23;
    is.eq 1u8 2u8 into r24;
    add r18.player2 r20 into r25;
    ternary r24 r25 r18.player2 into r26;
    cast r23 r26 r18.player3 0u16 0u16 0u16 into r27 as Chips;
    is.eq r27.player1 0u16 into r28;
    ternary r28 1u8 0u8 into r29;
    is.eq r27.player2 0u16 into r30;
    ternary r30 2u8 0u8 into r31;
    or r29 r31 into r32;
    is.eq r27.player3 0u16 into r33;
    ternary r33 4u8 0u8 into r34;
    or r32 r34 into r35;
    is.eq r35 6u8 into r36;
    branch.eq r36 false to end_then_1_8;
    branch.eq true true to end_otherwise_1_9;
    position end_then_1_8;
    is.eq r35 5u8 into r37;
    branch.eq r37 false to end_then_2_10;
    branch.eq true true to end_otherwise_2_11;
    position end_then_2_10;
    position end_otherwise_2_11;
    position end_otherwise_1_9;
    and r8.dealer_button 1u8 into r38;
    is.neq r38 0u8 into r39;
    and r8.dealer_button 2u8 into r40;
    is.neq r40 0u8 into r41;
    ternary r41 4u8 1u8 into r42;
    ternary r39 2u8 r42 into r43;
    sub r8.remaining_hands 1u8 into r44;
    is.eq r44 0u8 into r45;
    mul r8.sb 2u16 into r46;
    mul r8.bb 2u16 into r47;
    ternary r45 r46 r8.sb into r48;
    ternary r45 r47 r8.bb into r49;
    is.eq r44 0u8 into r50;
    ternary r50 10u8 r44 into r51;
    add r8.hands_played 1u8 into r52;
    cast r8.player1 r8.player2 r8.player3 r8.buy_in 29u8 r43 r35 r35 0u8 r48 r49 r51 r52 0u16 into r53 as Game;
    set r2 into cards[r0];
    set r27 into chips[r0];
    set r53 into games[r0];
    branch.eq true true to end_otherwise_0_7;
    position end_then_0_6;
    position end_otherwise_0_7;
    cast r8.player1 r8.player2 r8.player3 r8.buy_in 28u8 r8.dealer_button r8.players_out r8.players_folded r8.last_bet r8.sb r8.bb r8.remaining_hands r8.hands_played r8.last_raise_size into r54 as Game;
    set r2 into cards[r0];
    set r54 into games[r0];

function showdown_p3:
    input r0 as u32.private;
    input r1 as Cards.private;
    input r2 as Keys.record;
    call commutative_encryption.aleo/decrypt_card r2.secret_inv r1.player3[0u32] into r3;
    call commutative_encryption.aleo/decrypt_card r2.secret_inv r1.player3[1u32] into r4;
    cast r3 r4 into r5 as [group; 2u32];
    cast r1.player1 r1.player2 r5 r1.flop r1.turn r1.river into r6 as Cards;
    call commutative_encryption.aleo/to_u8 r6.player1[0u32] into r7;
    call commutative_encryption.aleo/to_u8 r6.player1[1u32] into r8;
    cast r7 r8 into r9 as [u8; 2u32];
    call commutative_encryption.aleo/to_u8 r6.player2[0u32] into r10;
    call commutative_encryption.aleo/to_u8 r6.player2[1u32] into r11;
    cast r10 r11 into r12 as [u8; 2u32];
    call commutative_encryption.aleo/to_u8 r6.player3[0u32] into r13;
    call commutative_encryption.aleo/to_u8 r6.player3[1u32] into r14;
    cast r13 r14 into r15 as [u8; 2u32];
    async showdown_p3 r0 r1 r6 self.caller r9 r12 r15 into r16;
    cast r2.owner r2.secret r2.secret_inv into r17 as Keys.record;
    output r17 as Keys.record;
    output r16 as poker.aleo/showdown_p3.future;

finalize showdown_p3:
    input r0 as u32.public;
    input r1 as Cards.public;
    input r2 as Cards.public;
    input r3 as address.public;
    input r4 as [u8; 2u32].public;
    input r5 as [u8; 2u32].public;
    input r6 as [u8; 2u32].public;
    get cards[r0] into r7;
    is.eq r1 r7 into r8;
    assert.eq r8 true;
    get games[r0] into r9;
    is.eq r9.state 28u8 into r10;
    assert.eq r10 true;
    is.eq r9.player3 r3 into r11;
    assert.eq r11 true;
    get revealed_cards[r0] into r12;
    cast r4 r5 r6 r12.flop r12.turn r12.river into r13 as RevealedCards;
    set r13 into revealed_cards[r0];
    and r9.players_folded 1u8 into r14;
    is.neq r14 0u8 into r15;
    not r15 into r16;
    gte r4[0u32] r4[1u32] into r17;
    ternary r17 r4[0u32] r4[1u32] into r18;
    ternary r16 r18 0u8 into r19;
    and r9.players_folded 2u8 into r20;
    is.neq r20 0u8 into r21;
    not r21 into r22;
    gte r5[0u32] r5[1u32] into r23;
    ternary r23 r5[0u32] r5[1u32] into r24;
    ternary r22 r24 0u8 into r25;
    and r9.players_folded 4u8 into r26;
    is.neq r26 0u8 into r27;
    not r27 into r28;
    gte r6[0u32] r6[1u32] into r29;
    ternary r29 r6[0u32] r6[1u32] into r30;
    ternary r28 r30 0u8 into r31;
    gte r19 r25 into r32;
    gte r19 r31 into r33;
    and r32 r33 into r34;
    gte r25 r31 into r35;
    ternary r35 2u8 3u8 into r36;
    ternary r34 1u8 r36 into r37;
    get chips[r0] into r38;
    add r38.player1_bet r38.player2_bet into r39;
    add r39 r38.player3_bet into r40;
    is.eq r37 1u8 into r41;
    add r38.player1 r40 into r42;
    ternary r41 r42 r38.player1 into r43;
    is.eq r37 2u8 into r44;
    add r38.player2 r40 into r45;
    ternary r44 r45 r38.player2 into r46;
    is.eq r37 3u8 into r47;
    add r38.player3 r40 into r48;
    ternary r47 r48 r38.player3 into r49;
    cast r43 r46 r49 0u16 0u16 0u16 into r50 as Chips;
    is.eq r50.player1 0u16 into r51;
    ternary r51 1u8 0u8 into r52;
    is.eq r50.player2 0u16 into r53;
    ternary r53 2u8 0u8 into r54;
    or r52 r54 into r55;
    is.eq r50.player3 0u16 into r56;
    ternary r56 4u8 0u8 into r57;
    or r55 r57 into r58;
    is.eq r58 6u8 into r59;
    branch.eq r59 false to end_then_0_12;
    branch.eq true true to end_otherwise_0_13;
    position end_then_0_12;
    is.eq r58 5u8 into r60;
    branch.eq r60 false to end_then_1_14;
    branch.eq true true to end_otherwise_1_15;
    position end_then_1_14;
    is.eq r58 3u8 into r61;
    branch.eq r61 false to end_then_2_16;
    branch.eq true true to end_otherwise_2_17;
    position end_then_2_16;
    position end_otherwise_2_17;
    position end_otherwise_1_15;
    position end_otherwise_0_13;
    and r9.dealer_button 1u8 into r62;
    is.neq r62 0u8 into r63;
    and r9.dealer_button 2u8 into r64;
    is.neq r64 0u8 into r65;
    ternary r65 4u8 1u8 into r66;
    ternary r63 2u8 r66 into r67;
    sub r9.remaining_hands 1u8 into r68;
    is.eq r68 0u8 into r69;
    mul r9.sb 2u16 into r70;
    mul r9.bb 2u16 into r71;
    ternary r69 r70 r9.sb into r72;
    ternary r69 r71 r9.bb into r73;
    is.eq r68 0u8 into r74;
    ternary r74 10u8 r68 into r75;
    add r9.hands_played 1u8 into r76;
    cast r9.player1 r9.player2 r9.player3 r9.buy_in 29u8 r67 r58 r58 0u8 r72 r73 r75 r76 0u16 into r77 as Game;
    set r2 into cards[r0];
    set r50 into chips[r0];
    set r77 into games[r0];

constructor:
    assert.eq edition 0u16;
