import zk_deck_shuffle.aleo;
import zk_sra_encryption.aleo;
program poker.aleo;

struct Game:
    player1 as address;
    player2 as address;
    player3 as address;
    buy_in as u64;
    deck as [[u128; 26u32]; 2u32];
    state as u8;
    dealer_button as u8;
    players_out as u8;
    players_folded as u8;
    last_bet as u8;
    sb as u16;
    bb as u16;
    remaining_hands as u8;
    hands_played as u8;
    last_raise_size as u16;

struct Chips:
    player1 as u16;
    player2 as u16;
    player3 as u16;
    player1_bet as u16;
    player2_bet as u16;
    player3_bet as u16;

struct Cards:
    player1 as [u128; 2u32];
    player2 as [u128; 2u32];
    player3 as [u128; 2u32];
    flop as [u128; 3u32];
    turn as u128;
    river as u128;

mapping games:
    key as u32.public;
    value as Game.public;

mapping chips:
    key as u32.public;
    value as Chips.public;

mapping cards:
    key as u32.public;
    value as Cards.public;

function create_game:
    input r0 as u32.private;
    input r1 as i8.private;
    input r2 as i8.private;
    input r3 as i8.private;
    input r4 as u128.private;
    input r5 as u128.private;
    cast  1u128 2u128 3u128 4u128 5u128 6u128 7u128 8u128 9u128 10u128 11u128 12u128 13u128 14u128 15u128 16u128 17u128 18u128 19u128 20u128 21u128 22u128 23u128 24u128 25u128 26u128 into r6 as [u128; 26u32];
    cast  27u128 28u128 29u128 30u128 31u128 32u128 33u128 34u128 35u128 36u128 37u128 38u128 39u128 40u128 41u128 42u128 43u128 44u128 45u128 46u128 47u128 48u128 49u128 50u128 51u128 52u128 into r7 as [u128; 26u32];
    cast  r6 r7 into r8 as [[u128; 26u32]; 2u32];
    call zk_sra_encryption.aleo/encrypt_deck r4 r5 r8 into r9;
    call zk_deck_shuffle.aleo/full_shuffle r1 r2 r3 r9 into r10;
    async create_game r0 r10 self.caller into r11;
    output r11 as poker.aleo/create_game.future;

finalize create_game:
    input r0 as u32.public;
    input r1 as [[u128; 26u32]; 2u32].public;
    input r2 as address.public;
    cast 0u128 into r3 as address;
    cast 0u128 into r4 as address;
    cast r2 r3 r4 10u64 r1 0u8 1u8 0u8 0u8 0u8 5u16 10u16 10u8 0u8 0u16 into r5 as Game;
    set r5 into games[r0];

function join_game:
    input r0 as u32.private;
    input r1 as [[u128; 26u32]; 2u32].private;
    input r2 as i8.private;
    input r3 as i8.private;
    input r4 as i8.private;
    input r5 as u128.private;
    input r6 as u128.private;
    call zk_sra_encryption.aleo/encrypt_deck r5 r6 r1 into r7;
    call zk_deck_shuffle.aleo/full_shuffle r2 r3 r4 r7 into r8;
    async join_game r0 r1 r8 self.caller into r9;
    output r9 as poker.aleo/join_game.future;

finalize join_game:
    input r0 as u32.public;
    input r1 as [[u128; 26u32]; 2u32].public;
    input r2 as [[u128; 26u32]; 2u32].public;
    input r3 as address.public;
    get games[r0] into r4;
    is.eq r4.deck r1 into r5;
    assert.eq r5 true;
    is.eq r4.state 0u8 into r6;
    is.eq r4.state 0u8 into r7;
    is.eq r4.state 1u8 into r8;
    or r7 r8 into r9;
    assert.eq r9 true;
    ternary r6 r3 r4.player2 into r10;
    not r6 into r11;
    cast 0u128 into r12 as address;
    ternary r11 r3 r12 into r13;
    ternary r6 1u8 2u8 into r14;
    cast r4.player1 r10 r13 r4.buy_in r2 r14 r4.dealer_button 0u8 0u8 0u8 r4.sb r4.bb r4.remaining_hands 0u8 0u16 into r15 as Game;
    set r15 into games[r0];
    not r6 into r16;
    branch.eq r16 false to end_then_0_0;
    sub 1000u16 r4.sb into r17;
    sub 1000u16 r4.bb into r18;
    cast r17 r18 1000u16 r4.sb r4.bb 0u16 into r19 as Chips;
    cast  r2[1u32][1u32] r2[1u32][4u32] into r20 as [u128; 2u32];
    cast  r2[1u32][2u32] r2[1u32][5u32] into r21 as [u128; 2u32];
    cast  r2[1u32][3u32] r2[1u32][6u32] into r22 as [u128; 2u32];
    cast  r2[1u32][7u32] r2[1u32][8u32] r2[1u32][9u32] into r23 as [u128; 3u32];
    cast r20 r21 r22 r23 r2[1u32][10u32] r2[1u32][11u32] into r24 as Cards;
    set r19 into chips[r0];
    set r24 into cards[r0];
    branch.eq true true to end_otherwise_0_1;
    position end_then_0_0;
    position end_otherwise_0_1;

function bet:
    input r0 as u32.private;
    input r1 as u16.private;
    async bet r0 r1 self.caller into r2;
    output r2 as poker.aleo/bet.future;

finalize bet:
    input r0 as u32.public;
    input r1 as u16.public;
    input r2 as address.public;
    get games[r0] into r3;
    get chips[r0] into r4;
    is.eq r3.state 4u8 into r5;
    is.eq r3.player1 r2 into r6;
    and r5 r6 into r7;
    is.eq r3.state 5u8 into r8;
    is.eq r3.player2 r2 into r9;
    and r8 r9 into r10;
    or r7 r10 into r11;
    is.eq r3.state 6u8 into r12;
    is.eq r3.player3 r2 into r13;
    and r12 r13 into r14;
    or r11 r14 into r15;
    is.eq r3.state 11u8 into r16;
    is.eq r3.player1 r2 into r17;
    and r16 r17 into r18;
    or r15 r18 into r19;
    is.eq r3.state 12u8 into r20;
    is.eq r3.player2 r2 into r21;
    and r20 r21 into r22;
    or r19 r22 into r23;
    is.eq r3.state 13u8 into r24;
    is.eq r3.player3 r2 into r25;
    and r24 r25 into r26;
    or r23 r26 into r27;
    is.eq r3.state 17u8 into r28;
    is.eq r3.player1 r2 into r29;
    and r28 r29 into r30;
    or r27 r30 into r31;
    is.eq r3.state 18u8 into r32;
    is.eq r3.player2 r2 into r33;
    and r32 r33 into r34;
    or r31 r34 into r35;
    is.eq r3.state 19u8 into r36;
    is.eq r3.player3 r2 into r37;
    and r36 r37 into r38;
    or r35 r38 into r39;
    is.eq r3.state 23u8 into r40;
    is.eq r3.player1 r2 into r41;
    and r40 r41 into r42;
    or r39 r42 into r43;
    is.eq r3.state 24u8 into r44;
    is.eq r3.player2 r2 into r45;
    and r44 r45 into r46;
    or r43 r46 into r47;
    is.eq r3.state 25u8 into r48;
    is.eq r3.player3 r2 into r49;
    and r48 r49 into r50;
    or r47 r50 into r51;
    assert.eq r51 true;
    is.eq r3.state 4u8 into r52;
    is.eq r3.state 11u8 into r53;
    or r52 r53 into r54;
    is.eq r3.state 17u8 into r55;
    or r54 r55 into r56;
    is.eq r3.state 23u8 into r57;
    or r56 r57 into r58;
    is.eq r3.state 5u8 into r59;
    is.eq r3.state 12u8 into r60;
    or r59 r60 into r61;
    is.eq r3.state 18u8 into r62;
    or r61 r62 into r63;
    is.eq r3.state 24u8 into r64;
    or r63 r64 into r65;
    ternary r65 r4.player2 r4.player3 into r66;
    ternary r65 r4.player2_bet r4.player3_bet into r67;
    ternary r58 r4.player1 r66 into r68;
    ternary r58 r4.player1_bet r67 into r69;
    gte r4.player1_bet r4.player2_bet into r70;
    gte r4.player1_bet r4.player3_bet into r71;
    and r70 r71 into r72;
    gte r4.player2_bet r4.player3_bet into r73;
    ternary r73 r4.player2_bet r4.player3_bet into r74;
    ternary r72 r4.player1_bet r74 into r75;
    is.eq r75 0u16 into r76;
    is.eq r3.last_raise_size 0u16 into r77;
    ternary r77 r3.bb r3.last_raise_size into r78;
    ternary r76 r3.bb r78 into r79;
    add r75 r79 into r80;
    sub r75 r69 into r81;
    is.eq r75 0u16 into r82;
    ternary r82 r3.bb r81 into r83;
    is.eq r1 r68 into r84;
    gte r1 r83 into r85;
    or r84 r85 into r86;
    assert.eq r86 true;
    is.eq r1 r68 into r87;
    is.eq r1 r81 into r88;
    or r87 r88 into r89;
    gte r1 r80 into r90;
    or r89 r90 into r91;
    gt r1 r75 into r92;
    not r91 into r93;
    and r92 r93 into r94;
    gt r1 r75 into r95;
    gte r1 r80 into r96;
    and r95 r96 into r97;
    not r91 into r98;
    and r97 r98 into r99;
    add r69 r1 into r100;
    sub r68 r1 into r101;
    is.eq r101 0u16 into r102;
    is.eq r4.player1 0u16 into r103;
    and r3.players_folded 1u8 into r104;
    is.neq r104 0u8 into r105;
    or r103 r105 into r106;
    and r3.players_out 1u8 into r107;
    is.neq r107 0u8 into r108;
    or r106 r108 into r109;
    is.eq r4.player2 0u16 into r110;
    and r3.players_folded 2u8 into r111;
    is.neq r111 0u8 into r112;
    or r110 r112 into r113;
    and r3.players_out 2u8 into r114;
    is.neq r114 0u8 into r115;
    or r113 r115 into r116;
    is.eq r4.player3 0u16 into r117;
    and r3.players_folded 4u8 into r118;
    is.neq r118 0u8 into r119;
    or r117 r119 into r120;
    and r3.players_out 4u8 into r121;
    is.neq r121 0u8 into r122;
    or r120 r122 into r123;
    not r109 into r124;
    cast r124 into r125 as u8;
    not r116 into r126;
    cast r126 into r127 as u8;
    add r125 r127 into r128;
    not r123 into r129;
    cast r129 into r130 as u8;
    add r128 r130 into r131;
    gt r131 1u8 into r132;
    is.eq r131 1u8 into r133;
    lt r69 r75 into r134;
    and r133 r134 into r135;
    or r132 r135 into r136;
    assert.eq r136 true;
    cast r102 into r137 as u8;
    sub r131 r137 into r138;
    is.eq r4.player1 0u16 into r139;
    lt r4.player1_bet r75 into r140;
    and r139 r140 into r141;
    is.eq r4.player2 0u16 into r142;
    lt r4.player2_bet r75 into r143;
    and r142 r143 into r144;
    or r141 r144 into r145;
    is.eq r4.player3 0u16 into r146;
    lt r4.player3_bet r75 into r147;
    and r146 r147 into r148;
    or r145 r148 into r149;
    is.eq r3.state 4u8 into r150;
    is.eq r3.state 11u8 into r151;
    or r150 r151 into r152;
    is.eq r3.state 17u8 into r153;
    or r152 r153 into r154;
    is.eq r3.state 23u8 into r155;
    or r154 r155 into r156;
    is.eq r3.state 5u8 into r157;
    is.eq r3.state 12u8 into r158;
    or r157 r158 into r159;
    is.eq r3.state 18u8 into r160;
    or r159 r160 into r161;
    is.eq r3.state 24u8 into r162;
    or r161 r162 into r163;
    ternary r163 2u8 4u8 into r164;
    ternary r156 1u8 r164 into r165;
    ternary r99 r165 r3.last_bet into r166;
    lte r138 1u8 into r167;
    gte r100 r75 into r168;
    is.eq r4.player1_bet r75 into r169;
    or r109 r169 into r170;
    is.eq r4.player2_bet r75 into r171;
    or r116 r171 into r172;
    and r170 r172 into r173;
    is.eq r4.player3_bet r75 into r174;
    or r123 r174 into r175;
    and r173 r175 into r176;
    and r168 r176 into r177;
    not r99 into r178;
    is.eq r3.last_bet 0u8 into r179;
    or r178 r179 into r180;
    or r180 r94 into r181;
    not r99 into r182;
    and r149 r182 into r183;
    is.eq r3.state 4u8 into r184;
    is.eq r3.state 11u8 into r185;
    or r184 r185 into r186;
    is.eq r3.state 17u8 into r187;
    or r186 r187 into r188;
    is.eq r3.state 23u8 into r189;
    or r188 r189 into r190;
    and r3.last_bet 1u8 into r191;
    is.neq r191 0u8 into r192;
    and r190 r192 into r193;
    and r183 r193 into r194;
    is.eq r3.state 5u8 into r195;
    is.eq r3.state 12u8 into r196;
    or r195 r196 into r197;
    is.eq r3.state 18u8 into r198;
    or r197 r198 into r199;
    is.eq r3.state 24u8 into r200;
    or r199 r200 into r201;
    and r3.last_bet 2u8 into r202;
    is.neq r202 0u8 into r203;
    and r201 r203 into r204;
    or r194 r204 into r205;
    is.eq r3.state 6u8 into r206;
    is.eq r3.state 13u8 into r207;
    or r206 r207 into r208;
    is.eq r3.state 19u8 into r209;
    or r208 r209 into r210;
    is.eq r3.state 25u8 into r211;
    or r210 r211 into r212;
    and r3.last_bet 4u8 into r213;
    is.neq r213 0u8 into r214;
    and r212 r214 into r215;
    or r205 r215 into r216;
    or r181 r216 into r217;
    and r177 r217 into r218;
    or r167 r218 into r219;
    lte r3.state 7u8 into r220;
    and r3.players_out 1u8 into r221;
    is.neq r221 0u8 into r222;
    ternary r222 8u8 7u8 into r223;
    lte r3.state 13u8 into r224;
    and r3.players_out 2u8 into r225;
    is.neq r225 0u8 into r226;
    ternary r226 14u8 13u8 into r227;
    lte r3.state 19u8 into r228;
    and r3.players_out 4u8 into r229;
    is.neq r229 0u8 into r230;
    ternary r230 20u8 19u8 into r231;
    and r3.players_folded 1u8 into r232;
    is.neq r232 0u8 into r233;
    and r3.players_folded 2u8 into r234;
    is.neq r234 0u8 into r235;
    ternary r235 28u8 27u8 into r236;
    ternary r233 r236 26u8 into r237;
    ternary r228 r231 r237 into r238;
    ternary r224 r227 r238 into r239;
    ternary r220 r223 r239 into r240;
    is.eq r3.state 4u8 into r241;
    ternary r116 6u8 5u8 into r242;
    is.eq r3.state 5u8 into r243;
    ternary r123 4u8 6u8 into r244;
    is.eq r3.state 6u8 into r245;
    ternary r109 5u8 4u8 into r246;
    is.eq r3.state 11u8 into r247;
    ternary r116 13u8 12u8 into r248;
    is.eq r3.state 12u8 into r249;
    ternary r123 11u8 13u8 into r250;
    is.eq r3.state 13u8 into r251;
    ternary r109 12u8 11u8 into r252;
    is.eq r3.state 17u8 into r253;
    ternary r116 19u8 18u8 into r254;
    is.eq r3.state 18u8 into r255;
    ternary r123 17u8 19u8 into r256;
    is.eq r3.state 19u8 into r257;
    ternary r109 18u8 17u8 into r258;
    is.eq r3.state 23u8 into r259;
    ternary r116 25u8 24u8 into r260;
    is.eq r3.state 24u8 into r261;
    ternary r123 23u8 25u8 into r262;
    is.eq r3.state 25u8 into r263;
    ternary r109 24u8 23u8 into r264;
    ternary r263 r264 0u8 into r265;
    ternary r261 r262 r265 into r266;
    ternary r259 r260 r266 into r267;
    ternary r257 r258 r267 into r268;
    ternary r255 r256 r268 into r269;
    ternary r253 r254 r269 into r270;
    ternary r251 r252 r270 into r271;
    ternary r249 r250 r271 into r272;
    ternary r247 r248 r272 into r273;
    ternary r245 r246 r273 into r274;
    ternary r243 r244 r274 into r275;
    ternary r241 r242 r275 into r276;
    ternary r219 r240 r276 into r277;
    gt r100 r75 into r278;
    not r102 into r279;
    and r278 r279 into r280;
    is.eq r3.state 4u8 into r281;
    is.eq r3.state 11u8 into r282;
    or r281 r282 into r283;
    is.eq r3.state 17u8 into r284;
    or r283 r284 into r285;
    is.eq r3.state 23u8 into r286;
    or r285 r286 into r287;
    is.eq r3.state 5u8 into r288;
    is.eq r3.state 12u8 into r289;
    or r288 r289 into r290;
    is.eq r3.state 18u8 into r291;
    or r290 r291 into r292;
    is.eq r3.state 24u8 into r293;
    or r292 r293 into r294;
    ternary r294 2u8 4u8 into r295;
    ternary r287 1u8 r295 into r296;
    ternary r280 r296 r3.last_bet into r297;
    add r4.player1_bet r4.player2_bet into r298;
    add r298 r4.player3_bet into r299;
    add r299 r1 into r300;
    is.eq r3.state 4u8 into r301;
    is.eq r3.state 11u8 into r302;
    or r301 r302 into r303;
    is.eq r3.state 17u8 into r304;
    or r303 r304 into r305;
    is.eq r3.state 23u8 into r306;
    or r305 r306 into r307;
    ternary r307 r101 r4.player1 into r308;
    is.eq r3.state 5u8 into r309;
    is.eq r3.state 12u8 into r310;
    or r309 r310 into r311;
    is.eq r3.state 18u8 into r312;
    or r311 r312 into r313;
    is.eq r3.state 24u8 into r314;
    or r313 r314 into r315;
    ternary r315 r101 r4.player2 into r316;
    is.eq r3.state 6u8 into r317;
    is.eq r3.state 13u8 into r318;
    or r317 r318 into r319;
    is.eq r3.state 19u8 into r320;
    or r319 r320 into r321;
    is.eq r3.state 25u8 into r322;
    or r321 r322 into r323;
    ternary r323 r101 r4.player3 into r324;
    is.eq r3.state 4u8 into r325;
    is.eq r3.state 11u8 into r326;
    or r325 r326 into r327;
    is.eq r3.state 17u8 into r328;
    or r327 r328 into r329;
    is.eq r3.state 23u8 into r330;
    or r329 r330 into r331;
    ternary r331 r100 r4.player1_bet into r332;
    is.eq r3.state 5u8 into r333;
    is.eq r3.state 12u8 into r334;
    or r333 r334 into r335;
    is.eq r3.state 18u8 into r336;
    or r335 r336 into r337;
    is.eq r3.state 24u8 into r338;
    or r337 r338 into r339;
    ternary r339 r100 r4.player2_bet into r340;
    is.eq r3.state 6u8 into r341;
    is.eq r3.state 13u8 into r342;
    or r341 r342 into r343;
    is.eq r3.state 19u8 into r344;
    or r343 r344 into r345;
    is.eq r3.state 25u8 into r346;
    or r345 r346 into r347;
    ternary r347 r100 r4.player3_bet into r348;
    cast r308 r316 r324 r332 r340 r348 into r349 as Chips;
    sub r100 r75 into r350;
    ternary r99 r350 r3.last_raise_size into r351;
    cast r3.player1 r3.player2 r3.player3 r3.buy_in r3.deck r277 r3.dealer_button r3.players_out r3.players_folded r297 r3.sb r3.bb r3.remaining_hands r3.hands_played r351 into r352 as Game;
    set r349 into chips[r0];
    set r352 into games[r0];

function decrypt_hands_p1:
    input r0 as u32.private;
    input r1 as u128.private;
    input r2 as u128.private;
    input r3 as Cards.private;
    call zk_sra_encryption.aleo/decrypt_card r1 r2 r3.player2[0u32] into r4;
    call zk_sra_encryption.aleo/decrypt_card r1 r2 r3.player2[1u32] into r5;
    cast  r4 r5 into r6 as [u128; 2u32];
    call zk_sra_encryption.aleo/decrypt_card r1 r2 r3.player3[0u32] into r7;
    call zk_sra_encryption.aleo/decrypt_card r1 r2 r3.player3[1u32] into r8;
    cast  r7 r8 into r9 as [u128; 2u32];
    cast r3.player1 r6 r9 r3.flop r3.turn r3.river into r10 as Cards;
    async decrypt_hands_p1 r0 r3 r10 self.caller into r11;
    output r11 as poker.aleo/decrypt_hands_p1.future;

finalize decrypt_hands_p1:
    input r0 as u32.public;
    input r1 as Cards.public;
    input r2 as Cards.public;
    input r3 as address.public;
    get cards[r0] into r4;
    is.eq r1 r4 into r5;
    assert.eq r5 true;
    get games[r0] into r6;
    is.eq r6.state 2u8 into r7;
    assert.eq r7 true;
    is.eq r6.player1 r3 into r8;
    assert.eq r8 true;
    and r6.players_out 2u8 into r9;
    is.neq r9 0u8 into r10;
    branch.eq r10 false to end_then_0_2;
    cast r6.player1 r6.player2 r6.player3 r6.buy_in r6.deck 4u8 r6.dealer_button r6.players_out r6.players_folded r6.last_bet r6.sb r6.bb r6.remaining_hands r6.hands_played r6.last_raise_size into r11 as Game;
    set r2 into cards[r0];
    set r11 into games[r0];
    branch.eq true true to end_otherwise_0_3;
    position end_then_0_2;
    cast r6.player1 r6.player2 r6.player3 r6.buy_in r6.deck 3u8 r6.dealer_button r6.players_out r6.players_folded r6.last_bet r6.sb r6.bb r6.remaining_hands r6.hands_played r6.last_raise_size into r12 as Game;
    set r2 into cards[r0];
    set r12 into games[r0];
    position end_otherwise_0_3;

function decrypt_hands_p2:
    input r0 as u32.private;
    input r1 as u128.private;
    input r2 as u128.private;
    input r3 as Cards.private;
    call zk_sra_encryption.aleo/decrypt_card r1 r2 r3.player1[0u32] into r4;
    call zk_sra_encryption.aleo/decrypt_card r1 r2 r3.player1[1u32] into r5;
    cast  r4 r5 into r6 as [u128; 2u32];
    call zk_sra_encryption.aleo/decrypt_card r1 r2 r3.player3[0u32] into r7;
    call zk_sra_encryption.aleo/decrypt_card r1 r2 r3.player3[1u32] into r8;
    cast  r7 r8 into r9 as [u128; 2u32];
    cast r6 r3.player2 r9 r3.flop r3.turn r3.river into r10 as Cards;
    async decrypt_hands_p2 r0 r3 r10 self.caller into r11;
    output r11 as poker.aleo/decrypt_hands_p2.future;

finalize decrypt_hands_p2:
    input r0 as u32.public;
    input r1 as Cards.public;
    input r2 as Cards.public;
    input r3 as address.public;
    get cards[r0] into r4;
    is.eq r1 r4 into r5;
    assert.eq r5 true;
    get games[r0] into r6;
    is.eq r6.state 3u8 into r7;
    assert.eq r7 true;
    is.eq r6.player2 r3 into r8;
    assert.eq r8 true;
    set r2 into cards[r0];
    and r6.players_out 4u8 into r9;
    is.neq r9 0u8 into r10;
    and r6.dealer_button 2u8 into r11;
    is.neq r11 0u8 into r12;
    ternary r12 5u8 6u8 into r13;
    ternary r10 r13 4u8 into r14;
    and r6.players_out 4u8 into r15;
    is.neq r15 0u8 into r16;
    and r6.dealer_button 2u8 into r17;
    is.neq r17 0u8 into r18;
    ternary r18 2u8 1u8 into r19;
    ternary r16 r19 r6.last_bet into r20;
    cast r6.player1 r6.player2 r6.player3 r6.buy_in r6.deck r14 r6.dealer_button r6.players_out r6.players_folded r20 r6.sb r6.bb r6.remaining_hands r6.hands_played r6.last_raise_size into r21 as Game;
    set r21 into games[r0];

function decrypt_hands_p3:
    input r0 as u32.private;
    input r1 as u128.private;
    input r2 as u128.private;
    input r3 as Cards.private;
    call zk_sra_encryption.aleo/decrypt_card r1 r2 r3.player1[0u32] into r4;
    call zk_sra_encryption.aleo/decrypt_card r1 r2 r3.player1[1u32] into r5;
    cast  r4 r5 into r6 as [u128; 2u32];
    call zk_sra_encryption.aleo/decrypt_card r1 r2 r3.player2[0u32] into r7;
    call zk_sra_encryption.aleo/decrypt_card r1 r2 r3.player2[1u32] into r8;
    cast  r7 r8 into r9 as [u128; 2u32];
    cast r6 r9 r3.player3 r3.flop r3.turn r3.river into r10 as Cards;
    async decrypt_hands_p3 r0 r3 r10 self.caller into r11;
    output r11 as poker.aleo/decrypt_hands_p3.future;

finalize decrypt_hands_p3:
    input r0 as u32.public;
    input r1 as Cards.public;
    input r2 as Cards.public;
    input r3 as address.public;
    get cards[r0] into r4;
    is.eq r1 r4 into r5;
    assert.eq r5 true;
    get games[r0] into r6;
    is.eq r6.state 4u8 into r7;
    assert.eq r7 true;
    is.eq r6.player3 r3 into r8;
    assert.eq r8 true;
    set r2 into cards[r0];
    and r6.players_out 1u8 into r9;
    is.neq r9 0u8 into r10;
    and r6.dealer_button 2u8 into r11;
    is.neq r11 0u8 into r12;
    ternary r12 7u8 6u8 into r13;
    and r6.players_out 2u8 into r14;
    is.neq r14 0u8 into r15;
    and r6.dealer_button 1u8 into r16;
    is.neq r16 0u8 into r17;
    ternary r17 7u8 5u8 into r18;
    and r6.players_out 4u8 into r19;
    is.neq r19 0u8 into r20;
    and r6.dealer_button 2u8 into r21;
    is.neq r21 0u8 into r22;
    ternary r22 5u8 6u8 into r23;
    and r6.dealer_button 1u8 into r24;
    is.neq r24 0u8 into r25;
    and r6.dealer_button 2u8 into r26;
    is.neq r26 0u8 into r27;
    ternary r27 5u8 6u8 into r28;
    ternary r25 7u8 r28 into r29;
    ternary r20 r23 r29 into r30;
    ternary r15 r18 r30 into r31;
    ternary r10 r13 r31 into r32;
    and r6.players_folded 1u8 into r33;
    is.neq r33 0u8 into r34;
    and r6.dealer_button 2u8 into r35;
    is.neq r35 0u8 into r36;
    ternary r36 2u8 4u8 into r37;
    and r6.players_folded 2u8 into r38;
    is.neq r38 0u8 into r39;
    and r6.dealer_button 1u8 into r40;
    is.neq r40 0u8 into r41;
    ternary r41 1u8 4u8 into r42;
    and r6.players_folded 4u8 into r43;
    is.neq r43 0u8 into r44;
    and r6.dealer_button 2u8 into r45;
    is.neq r45 0u8 into r46;
    ternary r46 2u8 1u8 into r47;
    and r6.dealer_button 1u8 into r48;
    is.neq r48 0u8 into r49;
    and r6.dealer_button 2u8 into r50;
    is.neq r50 0u8 into r51;
    ternary r51 4u8 1u8 into r52;
    ternary r49 2u8 r52 into r53;
    ternary r44 r47 r53 into r54;
    ternary r39 r42 r54 into r55;
    ternary r34 r37 r55 into r56;
    cast r6.player1 r6.player2 r6.player3 r6.buy_in r6.deck r32 r6.dealer_button r6.players_out r6.players_folded r56 r6.sb r6.bb r6.remaining_hands r6.hands_played r6.last_raise_size into r57 as Game;
    set r57 into games[r0];

function decrypt_flop_p1:
    input r0 as u32.private;
    input r1 as u128.private;
    input r2 as u128.private;
    input r3 as Cards.private;
    call zk_sra_encryption.aleo/decrypt_card r1 r2 r3.flop[0u32] into r4;
    call zk_sra_encryption.aleo/decrypt_card r1 r2 r3.flop[1u32] into r5;
    call zk_sra_encryption.aleo/decrypt_card r1 r2 r3.flop[2u32] into r6;
    cast  r4 r5 r6 into r7 as [u128; 3u32];
    cast r3.player1 r3.player2 r3.player3 r7 r3.turn r3.river into r8 as Cards;
    async decrypt_flop_p1 r0 r3 r8 self.caller into r9;
    output r9 as poker.aleo/decrypt_flop_p1.future;

finalize decrypt_flop_p1:
    input r0 as u32.public;
    input r1 as Cards.public;
    input r2 as Cards.public;
    input r3 as address.public;
    get cards[r0] into r4;
    is.eq r1 r4 into r5;
    assert.eq r5 true;
    get games[r0] into r6;
    is.eq r6.state 8u8 into r7;
    assert.eq r7 true;
    is.eq r6.player1 r3 into r8;
    assert.eq r8 true;
    and r6.players_out 1u8 into r9;
    is.neq r9 0u8 into r10;
    not r10 into r11;
    assert.eq r11 true;
    and r6.players_out 2u8 into r12;
    is.neq r12 0u8 into r13;
    not r13 into r14;
    ternary r14 9u8 10u8 into r15;
    cast r6.player1 r6.player2 r6.player3 r6.buy_in r6.deck r15 r6.dealer_button r6.players_out r6.players_folded 0u8 r6.sb r6.bb r6.remaining_hands r6.hands_played r6.last_raise_size into r16 as Game;
    set r2 into cards[r0];
    set r16 into games[r0];

function decrypt_flop_p2:
    input r0 as u32.private;
    input r1 as u128.private;
    input r2 as u128.private;
    input r3 as Cards.private;
    call zk_sra_encryption.aleo/decrypt_card r1 r2 r3.flop[0u32] into r4;
    call zk_sra_encryption.aleo/decrypt_card r1 r2 r3.flop[1u32] into r5;
    call zk_sra_encryption.aleo/decrypt_card r1 r2 r3.flop[2u32] into r6;
    cast  r4 r5 r6 into r7 as [u128; 3u32];
    cast r3.player1 r3.player2 r3.player3 r7 r3.turn r3.river into r8 as Cards;
    async decrypt_flop_p2 r0 r3 r8 self.caller into r9;
    output r9 as poker.aleo/decrypt_flop_p2.future;

finalize decrypt_flop_p2:
    input r0 as u32.public;
    input r1 as Cards.public;
    input r2 as Cards.public;
    input r3 as address.public;
    get cards[r0] into r4;
    is.eq r1 r4 into r5;
    assert.eq r5 true;
    get games[r0] into r6;
    is.eq r6.state 9u8 into r7;
    assert.eq r7 true;
    is.eq r6.player2 r3 into r8;
    assert.eq r8 true;
    and r6.players_out 2u8 into r9;
    is.neq r9 0u8 into r10;
    not r10 into r11;
    assert.eq r11 true;
    get chips[r0] into r12;
    is.eq r12.player1 0u16 into r13;
    and r6.players_folded 1u8 into r14;
    is.neq r14 0u8 into r15;
    or r13 r15 into r16;
    is.eq r12.player2 0u16 into r17;
    and r6.players_folded 2u8 into r18;
    is.neq r18 0u8 into r19;
    or r17 r19 into r20;
    is.eq r12.player3 0u16 into r21;
    and r6.players_folded 4u8 into r22;
    is.neq r22 0u8 into r23;
    or r21 r23 into r24;
    not r16 into r25;
    cast r25 into r26 as u8;
    not r20 into r27;
    cast r27 into r28 as u8;
    add r26 r28 into r29;
    not r24 into r30;
    cast r30 into r31 as u8;
    add r29 r31 into r32;
    lte r32 1u8 into r33;
    is.eq r12.player1 0u16 into r34;
    is.eq r12.player2 0u16 into r35;
    and r34 r35 into r36;
    is.eq r12.player3 0u16 into r37;
    and r36 r37 into r38;
    or r33 r38 into r39;
    and r6.players_out 4u8 into r40;
    is.neq r40 0u8 into r41;
    not r41 into r42;
    and r6.dealer_button 1u8 into r43;
    is.neq r43 0u8 into r44;
    not r20 into r45;
    not r24 into r46;
    ternary r46 13u8 11u8 into r47;
    ternary r45 12u8 r47 into r48;
    and r6.dealer_button 2u8 into r49;
    is.neq r49 0u8 into r50;
    not r24 into r51;
    not r16 into r52;
    ternary r52 11u8 12u8 into r53;
    ternary r51 13u8 r53 into r54;
    not r16 into r55;
    not r20 into r56;
    ternary r56 12u8 13u8 into r57;
    ternary r55 11u8 r57 into r58;
    ternary r50 r54 r58 into r59;
    ternary r44 r48 r59 into r60;
    ternary r39 14u8 r60 into r61;
    ternary r42 10u8 r61 into r62;
    cast r6.player1 r6.player2 r6.player3 r6.buy_in r6.deck r62 r6.dealer_button r6.players_out r6.players_folded 0u8 r6.sb r6.bb r6.remaining_hands r6.hands_played r6.last_raise_size into r63 as Game;
    set r2 into cards[r0];
    set r63 into games[r0];

function decrypt_flop_p3:
    input r0 as u32.private;
    input r1 as u128.private;
    input r2 as u128.private;
    input r3 as Cards.private;
    call zk_sra_encryption.aleo/decrypt_card r1 r2 r3.flop[0u32] into r4;
    call zk_sra_encryption.aleo/decrypt_card r1 r2 r3.flop[1u32] into r5;
    call zk_sra_encryption.aleo/decrypt_card r1 r2 r3.flop[2u32] into r6;
    cast  r4 r5 r6 into r7 as [u128; 3u32];
    cast r3.player1 r3.player2 r3.player3 r7 r3.turn r3.river into r8 as Cards;
    async decrypt_flop_p3 r0 r3 r8 self.caller into r9;
    output r9 as poker.aleo/decrypt_flop_p3.future;

finalize decrypt_flop_p3:
    input r0 as u32.public;
    input r1 as Cards.public;
    input r2 as Cards.public;
    input r3 as address.public;
    get cards[r0] into r4;
    is.eq r1 r4 into r5;
    assert.eq r5 true;
    get games[r0] into r6;
    is.eq r6.state 10u8 into r7;
    assert.eq r7 true;
    is.eq r6.player3 r3 into r8;
    assert.eq r8 true;
    and r6.players_out 4u8 into r9;
    is.neq r9 0u8 into r10;
    not r10 into r11;
    assert.eq r11 true;
    get chips[r0] into r12;
    is.eq r12.player1 0u16 into r13;
    and r6.players_folded 1u8 into r14;
    is.neq r14 0u8 into r15;
    or r13 r15 into r16;
    is.eq r12.player2 0u16 into r17;
    and r6.players_folded 2u8 into r18;
    is.neq r18 0u8 into r19;
    or r17 r19 into r20;
    is.eq r12.player3 0u16 into r21;
    and r6.players_folded 4u8 into r22;
    is.neq r22 0u8 into r23;
    or r21 r23 into r24;
    not r16 into r25;
    cast r25 into r26 as u8;
    not r20 into r27;
    cast r27 into r28 as u8;
    add r26 r28 into r29;
    not r24 into r30;
    cast r30 into r31 as u8;
    add r29 r31 into r32;
    lte r32 1u8 into r33;
    is.eq r12.player1 0u16 into r34;
    is.eq r12.player2 0u16 into r35;
    and r34 r35 into r36;
    is.eq r12.player3 0u16 into r37;
    and r36 r37 into r38;
    or r33 r38 into r39;
    and r6.dealer_button 1u8 into r40;
    is.neq r40 0u8 into r41;
    not r20 into r42;
    not r24 into r43;
    ternary r43 13u8 11u8 into r44;
    ternary r42 12u8 r44 into r45;
    and r6.dealer_button 2u8 into r46;
    is.neq r46 0u8 into r47;
    not r24 into r48;
    not r16 into r49;
    ternary r49 11u8 12u8 into r50;
    ternary r48 13u8 r50 into r51;
    not r16 into r52;
    not r20 into r53;
    ternary r53 12u8 13u8 into r54;
    ternary r52 11u8 r54 into r55;
    ternary r47 r51 r55 into r56;
    ternary r41 r45 r56 into r57;
    ternary r39 14u8 r57 into r58;
    cast r6.player1 r6.player2 r6.player3 r6.buy_in r6.deck r58 r6.dealer_button r6.players_out r6.players_folded 0u8 r6.sb r6.bb r6.remaining_hands r6.hands_played 0u16 into r59 as Game;
    set r2 into cards[r0];
    set r59 into games[r0];

function fold:
    input r0 as u32.private;
    async fold r0 self.caller into r1;
    output r1 as poker.aleo/fold.future;

finalize fold:
    input r0 as u32.public;
    input r1 as address.public;
    get games[r0] into r2;
    get chips[r0] into r3;
    gte r2.state 4u8 into r4;
    lte r2.state 7u8 into r5;
    and r4 r5 into r6;
    gte r2.state 11u8 into r7;
    lte r2.state 13u8 into r8;
    and r7 r8 into r9;
    or r6 r9 into r10;
    gte r2.state 17u8 into r11;
    lte r2.state 19u8 into r12;
    and r11 r12 into r13;
    or r10 r13 into r14;
    gte r2.state 23u8 into r15;
    lte r2.state 25u8 into r16;
    and r15 r16 into r17;
    or r14 r17 into r18;
    assert.eq r18 true;
    is.eq r2.player1 r1 into r19;
    is.eq r2.player2 r1 into r20;
    is.eq r2.player3 r1 into r21;
    or r19 r20 into r22;
    or r22 r21 into r23;
    assert.eq r23 true;
    ternary r20 2u8 4u8 into r24;
    ternary r19 1u8 r24 into r25;
    or r2.players_folded r25 into r26;
    and r26 1u8 into r27;
    is.neq r27 0u8 into r28;
    ternary r28 1u8 0u8 into r29;
    sub 3u8 r29 into r30;
    and r26 2u8 into r31;
    is.neq r31 0u8 into r32;
    ternary r32 1u8 0u8 into r33;
    sub r30 r33 into r34;
    and r26 4u8 into r35;
    is.neq r35 0u8 into r36;
    ternary r36 1u8 0u8 into r37;
    sub r34 r37 into r38;
    is.eq r38 1u8 into r39;
    branch.eq r39 false to end_then_0_4;
    add r3.player1_bet r3.player2_bet into r40;
    add r40 r3.player3_bet into r41;
    and r26 1u8 into r42;
    is.neq r42 0u8 into r43;
    not r43 into r44;
    add r3.player1 r41 into r45;
    ternary r44 r45 r3.player1 into r46;
    and r26 2u8 into r47;
    is.neq r47 0u8 into r48;
    not r48 into r49;
    add r3.player2 r41 into r50;
    ternary r49 r50 r3.player2 into r51;
    and r26 4u8 into r52;
    is.neq r52 0u8 into r53;
    not r53 into r54;
    add r3.player3 r41 into r55;
    ternary r54 r55 r3.player3 into r56;
    cast r46 r51 r56 0u16 0u16 0u16 into r57 as Chips;
    and r2.players_out 1u8 into r58;
    is.neq r58 0u8 into r59;
    not r59 into r60;
    and r2.players_out 2u8 into r61;
    is.neq r61 0u8 into r62;
    not r62 into r63;
    ternary r63 30u8 31u8 into r64;
    ternary r60 29u8 r64 into r65;
    cast r2.player1 r2.player2 r2.player3 r2.buy_in r2.deck r65 r2.dealer_button r2.players_out r26 0u8 r2.sb r2.bb r2.remaining_hands r2.hands_played 0u16 into r66 as Game;
    set r57 into chips[r0];
    set r66 into games[r0];
    branch.eq true true to end_otherwise_0_5;
    position end_then_0_4;
    position end_otherwise_0_5;
    gte r3.player1_bet r3.player2_bet into r67;
    gte r3.player1_bet r3.player3_bet into r68;
    and r67 r68 into r69;
    gte r3.player2_bet r3.player3_bet into r70;
    ternary r70 r3.player2_bet r3.player3_bet into r71;
    ternary r69 r3.player1_bet r71 into r72;
    and r26 1u8 into r73;
    is.neq r73 0u8 into r74;
    is.eq r3.player1_bet r72 into r75;
    or r74 r75 into r76;
    and r26 2u8 into r77;
    is.neq r77 0u8 into r78;
    is.eq r3.player2_bet r72 into r79;
    or r78 r79 into r80;
    and r76 r80 into r81;
    and r26 4u8 into r82;
    is.neq r82 0u8 into r83;
    is.eq r3.player3_bet r72 into r84;
    or r83 r84 into r85;
    and r81 r85 into r86;
    lte r2.state 7u8 into r87;
    lte r2.state 13u8 into r88;
    lte r2.state 19u8 into r89;
    ternary r89 17u8 23u8 into r90;
    ternary r88 11u8 r90 into r91;
    ternary r87 4u8 r91 into r92;
    lte r2.state 7u8 into r93;
    and r2.players_out 1u8 into r94;
    is.neq r94 0u8 into r95;
    ternary r95 9u8 8u8 into r96;
    lte r2.state 13u8 into r97;
    and r2.players_out 1u8 into r98;
    is.neq r98 0u8 into r99;
    ternary r99 15u8 14u8 into r100;
    lte r2.state 19u8 into r101;
    and r2.players_out 1u8 into r102;
    is.neq r102 0u8 into r103;
    ternary r103 21u8 20u8 into r104;
    and r2.players_out 1u8 into r105;
    is.neq r105 0u8 into r106;
    ternary r106 27u8 26u8 into r107;
    ternary r101 r104 r107 into r108;
    ternary r97 r100 r108 into r109;
    ternary r93 r96 r109 into r110;
    and r26 2u8 into r111;
    is.neq r111 0u8 into r112;
    add r92 2u8 into r113;
    add r92 1u8 into r114;
    ternary r112 r113 r114 into r115;
    and r26 4u8 into r116;
    is.neq r116 0u8 into r117;
    add r92 2u8 into r118;
    ternary r117 r92 r118 into r119;
    and r26 1u8 into r120;
    is.neq r120 0u8 into r121;
    add r92 1u8 into r122;
    ternary r121 r122 r92 into r123;
    ternary r20 r119 r123 into r124;
    ternary r19 r115 r124 into r125;
    ternary r86 r110 r125 into r126;
    ternary r86 0u8 r2.last_bet into r127;
    ternary r86 0u16 r2.last_raise_size into r128;
    cast r2.player1 r2.player2 r2.player3 r2.buy_in r2.deck r126 r2.dealer_button r2.players_out r26 r127 r2.sb r2.bb r2.remaining_hands r2.hands_played r128 into r129 as Game;
    set r129 into games[r0];

function decrypt_turn_p1:
    input r0 as u32.private;
    input r1 as u128.private;
    input r2 as u128.private;
    input r3 as Cards.private;
    call zk_sra_encryption.aleo/decrypt_card r1 r2 r3.turn into r4;
    cast r3.player1 r3.player2 r3.player3 r3.flop r4 r3.river into r5 as Cards;
    async decrypt_turn_p1 r0 r3 r5 self.caller into r6;
    output r6 as poker.aleo/decrypt_turn_p1.future;

finalize decrypt_turn_p1:
    input r0 as u32.public;
    input r1 as Cards.public;
    input r2 as Cards.public;
    input r3 as address.public;
    get cards[r0] into r4;
    is.eq r1 r4 into r5;
    assert.eq r5 true;
    get games[r0] into r6;
    is.eq r6.state 14u8 into r7;
    assert.eq r7 true;
    is.eq r6.player1 r3 into r8;
    assert.eq r8 true;
    and r6.players_out 1u8 into r9;
    is.neq r9 0u8 into r10;
    not r10 into r11;
    assert.eq r11 true;
    and r6.players_out 2u8 into r12;
    is.neq r12 0u8 into r13;
    not r13 into r14;
    ternary r14 15u8 16u8 into r15;
    cast r6.player1 r6.player2 r6.player3 r6.buy_in r6.deck r15 r6.dealer_button r6.players_out r6.players_folded 0u8 r6.sb r6.bb r6.remaining_hands r6.hands_played r6.last_raise_size into r16 as Game;
    set r2 into cards[r0];
    set r16 into games[r0];

function decrypt_turn_p2:
    input r0 as u32.private;
    input r1 as u128.private;
    input r2 as u128.private;
    input r3 as Cards.private;
    call zk_sra_encryption.aleo/decrypt_card r1 r2 r3.turn into r4;
    cast r3.player1 r3.player2 r3.player3 r3.flop r4 r3.river into r5 as Cards;
    async decrypt_turn_p2 r0 r3 r5 self.caller into r6;
    output r6 as poker.aleo/decrypt_turn_p2.future;

finalize decrypt_turn_p2:
    input r0 as u32.public;
    input r1 as Cards.public;
    input r2 as Cards.public;
    input r3 as address.public;
    get cards[r0] into r4;
    is.eq r1 r4 into r5;
    assert.eq r5 true;
    get games[r0] into r6;
    is.eq r6.state 15u8 into r7;
    assert.eq r7 true;
    is.eq r6.player2 r3 into r8;
    assert.eq r8 true;
    and r6.players_out 2u8 into r9;
    is.neq r9 0u8 into r10;
    not r10 into r11;
    assert.eq r11 true;
    get chips[r0] into r12;
    is.eq r12.player1 0u16 into r13;
    and r6.players_folded 1u8 into r14;
    is.neq r14 0u8 into r15;
    or r13 r15 into r16;
    is.eq r12.player2 0u16 into r17;
    and r6.players_folded 2u8 into r18;
    is.neq r18 0u8 into r19;
    or r17 r19 into r20;
    is.eq r12.player3 0u16 into r21;
    and r6.players_folded 4u8 into r22;
    is.neq r22 0u8 into r23;
    or r21 r23 into r24;
    not r16 into r25;
    cast r25 into r26 as u8;
    not r20 into r27;
    cast r27 into r28 as u8;
    add r26 r28 into r29;
    not r24 into r30;
    cast r30 into r31 as u8;
    add r29 r31 into r32;
    lte r32 1u8 into r33;
    is.eq r12.player1 0u16 into r34;
    is.eq r12.player2 0u16 into r35;
    and r34 r35 into r36;
    is.eq r12.player3 0u16 into r37;
    and r36 r37 into r38;
    or r33 r38 into r39;
    and r6.players_out 4u8 into r40;
    is.neq r40 0u8 into r41;
    not r41 into r42;
    and r6.dealer_button 1u8 into r43;
    is.neq r43 0u8 into r44;
    not r20 into r45;
    not r24 into r46;
    ternary r46 19u8 17u8 into r47;
    ternary r45 18u8 r47 into r48;
    and r6.dealer_button 2u8 into r49;
    is.neq r49 0u8 into r50;
    not r24 into r51;
    not r16 into r52;
    ternary r52 17u8 18u8 into r53;
    ternary r51 19u8 r53 into r54;
    not r16 into r55;
    not r20 into r56;
    ternary r56 18u8 19u8 into r57;
    ternary r55 17u8 r57 into r58;
    ternary r50 r54 r58 into r59;
    ternary r44 r48 r59 into r60;
    ternary r39 20u8 r60 into r61;
    ternary r42 16u8 r61 into r62;
    cast r6.player1 r6.player2 r6.player3 r6.buy_in r6.deck r62 r6.dealer_button r6.players_out r6.players_folded 0u8 r6.sb r6.bb r6.remaining_hands r6.hands_played r6.last_raise_size into r63 as Game;
    set r2 into cards[r0];
    set r63 into games[r0];

function decrypt_turn_p3:
    input r0 as u32.private;
    input r1 as u128.private;
    input r2 as u128.private;
    input r3 as Cards.private;
    call zk_sra_encryption.aleo/decrypt_card r1 r2 r3.turn into r4;
    cast r3.player1 r3.player2 r3.player3 r3.flop r4 r3.river into r5 as Cards;
    async decrypt_turn_p3 r0 r3 r5 self.caller into r6;
    output r6 as poker.aleo/decrypt_turn_p3.future;

finalize decrypt_turn_p3:
    input r0 as u32.public;
    input r1 as Cards.public;
    input r2 as Cards.public;
    input r3 as address.public;
    get cards[r0] into r4;
    is.eq r1 r4 into r5;
    assert.eq r5 true;
    get games[r0] into r6;
    is.eq r6.state 16u8 into r7;
    assert.eq r7 true;
    is.eq r6.player3 r3 into r8;
    assert.eq r8 true;
    and r6.players_out 4u8 into r9;
    is.neq r9 0u8 into r10;
    not r10 into r11;
    assert.eq r11 true;
    get chips[r0] into r12;
    is.eq r12.player1 0u16 into r13;
    and r6.players_folded 1u8 into r14;
    is.neq r14 0u8 into r15;
    or r13 r15 into r16;
    is.eq r12.player2 0u16 into r17;
    and r6.players_folded 2u8 into r18;
    is.neq r18 0u8 into r19;
    or r17 r19 into r20;
    is.eq r12.player3 0u16 into r21;
    and r6.players_folded 4u8 into r22;
    is.neq r22 0u8 into r23;
    or r21 r23 into r24;
    not r16 into r25;
    cast r25 into r26 as u8;
    not r20 into r27;
    cast r27 into r28 as u8;
    add r26 r28 into r29;
    not r24 into r30;
    cast r30 into r31 as u8;
    add r29 r31 into r32;
    lte r32 1u8 into r33;
    is.eq r12.player1 0u16 into r34;
    is.eq r12.player2 0u16 into r35;
    and r34 r35 into r36;
    is.eq r12.player3 0u16 into r37;
    and r36 r37 into r38;
    or r33 r38 into r39;
    and r6.dealer_button 1u8 into r40;
    is.neq r40 0u8 into r41;
    not r20 into r42;
    not r24 into r43;
    ternary r43 19u8 17u8 into r44;
    ternary r42 18u8 r44 into r45;
    and r6.dealer_button 2u8 into r46;
    is.neq r46 0u8 into r47;
    not r24 into r48;
    not r16 into r49;
    ternary r49 17u8 18u8 into r50;
    ternary r48 19u8 r50 into r51;
    not r16 into r52;
    not r20 into r53;
    ternary r53 18u8 19u8 into r54;
    ternary r52 17u8 r54 into r55;
    ternary r47 r51 r55 into r56;
    ternary r41 r45 r56 into r57;
    ternary r39 20u8 r57 into r58;
    cast r6.player1 r6.player2 r6.player3 r6.buy_in r6.deck r58 r6.dealer_button r6.players_out r6.players_folded 0u8 r6.sb r6.bb r6.remaining_hands r6.hands_played 0u16 into r59 as Game;
    set r2 into cards[r0];
    set r59 into games[r0];

function decrypt_river_p1:
    input r0 as u32.private;
    input r1 as u128.private;
    input r2 as u128.private;
    input r3 as Cards.private;
    call zk_sra_encryption.aleo/decrypt_card r1 r2 r3.river into r4;
    cast r3.player1 r3.player2 r3.player3 r3.flop r3.turn r4 into r5 as Cards;
    async decrypt_river_p1 r0 r3 r5 self.caller into r6;
    output r6 as poker.aleo/decrypt_river_p1.future;

finalize decrypt_river_p1:
    input r0 as u32.public;
    input r1 as Cards.public;
    input r2 as Cards.public;
    input r3 as address.public;
    get cards[r0] into r4;
    is.eq r1 r4 into r5;
    assert.eq r5 true;
    get games[r0] into r6;
    is.eq r6.state 20u8 into r7;
    assert.eq r7 true;
    is.eq r6.player1 r3 into r8;
    assert.eq r8 true;
    and r6.players_out 1u8 into r9;
    is.neq r9 0u8 into r10;
    not r10 into r11;
    assert.eq r11 true;
    and r6.players_out 2u8 into r12;
    is.neq r12 0u8 into r13;
    not r13 into r14;
    ternary r14 21u8 22u8 into r15;
    cast r6.player1 r6.player2 r6.player3 r6.buy_in r6.deck r15 r6.dealer_button r6.players_out r6.players_folded 0u8 r6.sb r6.bb r6.remaining_hands r6.hands_played r6.last_raise_size into r16 as Game;
    set r2 into cards[r0];
    set r16 into games[r0];

function decrypt_river_p2:
    input r0 as u32.private;
    input r1 as u128.private;
    input r2 as u128.private;
    input r3 as Cards.private;
    call zk_sra_encryption.aleo/decrypt_card r1 r2 r3.river into r4;
    cast r3.player1 r3.player2 r3.player3 r3.flop r3.turn r4 into r5 as Cards;
    async decrypt_river_p2 r0 r3 r5 self.caller into r6;
    output r6 as poker.aleo/decrypt_river_p2.future;

finalize decrypt_river_p2:
    input r0 as u32.public;
    input r1 as Cards.public;
    input r2 as Cards.public;
    input r3 as address.public;
    get cards[r0] into r4;
    is.eq r1 r4 into r5;
    assert.eq r5 true;
    get games[r0] into r6;
    is.eq r6.state 21u8 into r7;
    assert.eq r7 true;
    is.eq r6.player2 r3 into r8;
    assert.eq r8 true;
    and r6.players_out 2u8 into r9;
    is.neq r9 0u8 into r10;
    not r10 into r11;
    assert.eq r11 true;
    get chips[r0] into r12;
    is.eq r12.player1 0u16 into r13;
    and r6.players_folded 1u8 into r14;
    is.neq r14 0u8 into r15;
    or r13 r15 into r16;
    is.eq r12.player2 0u16 into r17;
    and r6.players_folded 2u8 into r18;
    is.neq r18 0u8 into r19;
    or r17 r19 into r20;
    is.eq r12.player3 0u16 into r21;
    and r6.players_folded 4u8 into r22;
    is.neq r22 0u8 into r23;
    or r21 r23 into r24;
    not r16 into r25;
    cast r25 into r26 as u8;
    not r20 into r27;
    cast r27 into r28 as u8;
    add r26 r28 into r29;
    not r24 into r30;
    cast r30 into r31 as u8;
    add r29 r31 into r32;
    lte r32 1u8 into r33;
    is.eq r12.player1 0u16 into r34;
    is.eq r12.player2 0u16 into r35;
    and r34 r35 into r36;
    is.eq r12.player3 0u16 into r37;
    and r36 r37 into r38;
    or r33 r38 into r39;
    and r6.players_out 4u8 into r40;
    is.neq r40 0u8 into r41;
    not r41 into r42;
    and r6.dealer_button 1u8 into r43;
    is.neq r43 0u8 into r44;
    not r20 into r45;
    not r24 into r46;
    ternary r46 25u8 23u8 into r47;
    ternary r45 24u8 r47 into r48;
    and r6.dealer_button 2u8 into r49;
    is.neq r49 0u8 into r50;
    not r24 into r51;
    not r16 into r52;
    ternary r52 23u8 24u8 into r53;
    ternary r51 25u8 r53 into r54;
    not r16 into r55;
    not r20 into r56;
    ternary r56 24u8 25u8 into r57;
    ternary r55 23u8 r57 into r58;
    ternary r50 r54 r58 into r59;
    ternary r44 r48 r59 into r60;
    ternary r39 26u8 r60 into r61;
    ternary r42 22u8 r61 into r62;
    cast r6.player1 r6.player2 r6.player3 r6.buy_in r6.deck r62 r6.dealer_button r6.players_out r6.players_folded 0u8 r6.sb r6.bb r6.remaining_hands r6.hands_played r6.last_raise_size into r63 as Game;
    set r2 into cards[r0];
    set r63 into games[r0];

function decrypt_river_p3:
    input r0 as u32.private;
    input r1 as u128.private;
    input r2 as u128.private;
    input r3 as Cards.private;
    call zk_sra_encryption.aleo/decrypt_card r1 r2 r3.river into r4;
    cast r3.player1 r3.player2 r3.player3 r3.flop r3.turn r4 into r5 as Cards;
    async decrypt_river_p3 r0 r3 r5 self.caller into r6;
    output r6 as poker.aleo/decrypt_river_p3.future;

finalize decrypt_river_p3:
    input r0 as u32.public;
    input r1 as Cards.public;
    input r2 as Cards.public;
    input r3 as address.public;
    get cards[r0] into r4;
    is.eq r1 r4 into r5;
    assert.eq r5 true;
    get games[r0] into r6;
    is.eq r6.state 22u8 into r7;
    assert.eq r7 true;
    is.eq r6.player3 r3 into r8;
    assert.eq r8 true;
    and r6.players_out 4u8 into r9;
    is.neq r9 0u8 into r10;
    not r10 into r11;
    assert.eq r11 true;
    get chips[r0] into r12;
    is.eq r12.player1 0u16 into r13;
    and r6.players_folded 1u8 into r14;
    is.neq r14 0u8 into r15;
    or r13 r15 into r16;
    is.eq r12.player2 0u16 into r17;
    and r6.players_folded 2u8 into r18;
    is.neq r18 0u8 into r19;
    or r17 r19 into r20;
    is.eq r12.player3 0u16 into r21;
    and r6.players_folded 4u8 into r22;
    is.neq r22 0u8 into r23;
    or r21 r23 into r24;
    not r16 into r25;
    cast r25 into r26 as u8;
    not r20 into r27;
    cast r27 into r28 as u8;
    add r26 r28 into r29;
    not r24 into r30;
    cast r30 into r31 as u8;
    add r29 r31 into r32;
    lte r32 1u8 into r33;
    is.eq r12.player1 0u16 into r34;
    is.eq r12.player2 0u16 into r35;
    and r34 r35 into r36;
    is.eq r12.player3 0u16 into r37;
    and r36 r37 into r38;
    or r33 r38 into r39;
    and r6.dealer_button 1u8 into r40;
    is.neq r40 0u8 into r41;
    not r20 into r42;
    not r24 into r43;
    ternary r43 25u8 23u8 into r44;
    ternary r42 24u8 r44 into r45;
    and r6.dealer_button 2u8 into r46;
    is.neq r46 0u8 into r47;
    not r24 into r48;
    not r16 into r49;
    ternary r49 23u8 24u8 into r50;
    ternary r48 25u8 r50 into r51;
    not r16 into r52;
    not r20 into r53;
    ternary r53 24u8 25u8 into r54;
    ternary r52 23u8 r54 into r55;
    ternary r47 r51 r55 into r56;
    ternary r41 r45 r56 into r57;
    ternary r39 26u8 r57 into r58;
    cast r6.player1 r6.player2 r6.player3 r6.buy_in r6.deck r58 r6.dealer_button r6.players_out r6.players_folded 0u8 r6.sb r6.bb r6.remaining_hands r6.hands_played 0u16 into r59 as Game;
    set r2 into cards[r0];
    set r59 into games[r0];

function showdown_p1:
    input r0 as u32.private;
    input r1 as u128.private;
    input r2 as u128.private;
    input r3 as Cards.private;
    call zk_sra_encryption.aleo/decrypt_card r1 r2 r3.player1[0u32] into r4;
    call zk_sra_encryption.aleo/decrypt_card r1 r2 r3.player1[1u32] into r5;
    cast  r4 r5 into r6 as [u128; 2u32];
    cast r6 r3.player2 r3.player3 r3.flop r3.turn r3.river into r7 as Cards;
    async showdown_p1 r0 r3 r7 self.caller into r8;
    output r8 as poker.aleo/showdown_p1.future;

finalize showdown_p1:
    input r0 as u32.public;
    input r1 as Cards.public;
    input r2 as Cards.public;
    input r3 as address.public;
    get cards[r0] into r4;
    is.eq r1 r4 into r5;
    assert.eq r5 true;
    get games[r0] into r6;
    is.eq r6.state 26u8 into r7;
    assert.eq r7 true;
    is.eq r6.player1 r3 into r8;
    assert.eq r8 true;
    and r6.players_out 2u8 into r9;
    is.neq r9 0u8 into r10;
    not r10 into r11;
    ternary r11 27u8 28u8 into r12;
    cast r6.player1 r6.player2 r6.player3 r6.buy_in r6.deck r12 r6.dealer_button r6.players_out r6.players_folded r6.last_bet r6.sb r6.bb r6.remaining_hands r6.hands_played r6.last_raise_size into r13 as Game;
    set r2 into cards[r0];
    set r13 into games[r0];

function showdown_p2:
    input r0 as u32.private;
    input r1 as u128.private;
    input r2 as u128.private;
    input r3 as Cards.private;
    call zk_sra_encryption.aleo/decrypt_card r1 r2 r3.player2[0u32] into r4;
    call zk_sra_encryption.aleo/decrypt_card r1 r2 r3.player2[1u32] into r5;
    cast  r4 r5 into r6 as [u128; 2u32];
    cast r3.player1 r6 r3.player3 r3.flop r3.turn r3.river into r7 as Cards;
    async showdown_p2 r0 r3 r7 self.caller into r8;
    output r8 as poker.aleo/showdown_p2.future;

finalize showdown_p2:
    input r0 as u32.public;
    input r1 as Cards.public;
    input r2 as Cards.public;
    input r3 as address.public;
    get cards[r0] into r4;
    is.eq r1 r4 into r5;
    assert.eq r5 true;
    get games[r0] into r6;
    is.eq r6.state 27u8 into r7;
    assert.eq r7 true;
    is.eq r6.player2 r3 into r8;
    assert.eq r8 true;
    and r6.players_out 4u8 into r9;
    is.neq r9 0u8 into r10;
    and r6.players_folded 4u8 into r11;
    is.neq r11 0u8 into r12;
    or r10 r12 into r13;
    branch.eq r13 false to end_then_0_6;
    and r6.players_folded 1u8 into r14;
    is.neq r14 0u8 into r15;
    not r15 into r16;
    gte r2.player1[0u32] r2.player1[1u32] into r17;
    ternary r17 r2.player1[0u32] r2.player1[1u32] into r18;
    ternary r16 r18 0u128 into r19;
    and r6.players_folded 2u8 into r20;
    is.neq r20 0u8 into r21;
    not r21 into r22;
    gte r2.player2[0u32] r2.player2[1u32] into r23;
    ternary r23 r2.player2[0u32] r2.player2[1u32] into r24;
    ternary r22 r24 0u128 into r25;
    gte r19 r25 into r26;
    ternary r26 1u8 2u8 into r27;
    get chips[r0] into r28;
    add r28.player1_bet r28.player2_bet into r29;
    add r29 r28.player3_bet into r30;
    is.eq r27 1u8 into r31;
    add r28.player1 r30 into r32;
    ternary r31 r32 r28.player1 into r33;
    is.eq r27 2u8 into r34;
    add r28.player2 r30 into r35;
    ternary r34 r35 r28.player2 into r36;
    cast r33 r36 r28.player3 0u16 0u16 0u16 into r37 as Chips;
    is.eq r37.player1 0u16 into r38;
    ternary r38 1u8 0u8 into r39;
    is.eq r37.player2 0u16 into r40;
    ternary r40 2u8 0u8 into r41;
    or r39 r41 into r42;
    is.eq r37.player3 0u16 into r43;
    ternary r43 4u8 0u8 into r44;
    or r42 r44 into r45;
    is.eq r45 6u8 into r46;
    branch.eq r46 false to end_then_1_8;
    branch.eq true true to end_otherwise_1_9;
    position end_then_1_8;
    is.eq r45 5u8 into r47;
    branch.eq r47 false to end_then_2_10;
    branch.eq true true to end_otherwise_2_11;
    position end_then_2_10;
    position end_otherwise_2_11;
    position end_otherwise_1_9;
    and r6.dealer_button 1u8 into r48;
    is.neq r48 0u8 into r49;
    and r6.dealer_button 2u8 into r50;
    is.neq r50 0u8 into r51;
    ternary r51 4u8 1u8 into r52;
    ternary r49 2u8 r52 into r53;
    sub r6.remaining_hands 1u8 into r54;
    is.eq r54 0u8 into r55;
    mul r6.sb 2u16 into r56;
    mul r6.bb 2u16 into r57;
    ternary r55 r56 r6.sb into r58;
    ternary r55 r57 r6.bb into r59;
    is.eq r54 0u8 into r60;
    ternary r60 10u8 r54 into r61;
    add r6.hands_played 1u8 into r62;
    cast r6.player1 r6.player2 r6.player3 r6.buy_in r6.deck 29u8 r53 r45 r45 0u8 r58 r59 r61 r62 0u16 into r63 as Game;
    set r2 into cards[r0];
    set r37 into chips[r0];
    set r63 into games[r0];
    branch.eq true true to end_otherwise_0_7;
    position end_then_0_6;
    position end_otherwise_0_7;
    cast r6.player1 r6.player2 r6.player3 r6.buy_in r6.deck 28u8 r6.dealer_button r6.players_out r6.players_folded r6.last_bet r6.sb r6.bb r6.remaining_hands r6.hands_played r6.last_raise_size into r64 as Game;
    set r2 into cards[r0];
    set r64 into games[r0];

function showdown_p3:
    input r0 as u32.private;
    input r1 as u128.private;
    input r2 as u128.private;
    input r3 as Cards.private;
    call zk_sra_encryption.aleo/decrypt_card r1 r2 r3.player3[0u32] into r4;
    call zk_sra_encryption.aleo/decrypt_card r1 r2 r3.player3[1u32] into r5;
    cast  r4 r5 into r6 as [u128; 2u32];
    cast r3.player1 r3.player2 r6 r3.flop r3.turn r3.river into r7 as Cards;
    async showdown_p3 r0 r3 r7 self.caller into r8;
    output r8 as poker.aleo/showdown_p3.future;

finalize showdown_p3:
    input r0 as u32.public;
    input r1 as Cards.public;
    input r2 as Cards.public;
    input r3 as address.public;
    get cards[r0] into r4;
    is.eq r1 r4 into r5;
    assert.eq r5 true;
    get games[r0] into r6;
    is.eq r6.state 28u8 into r7;
    assert.eq r7 true;
    is.eq r6.player3 r3 into r8;
    assert.eq r8 true;
    and r6.players_folded 1u8 into r9;
    is.neq r9 0u8 into r10;
    not r10 into r11;
    gte r2.player1[0u32] r2.player1[1u32] into r12;
    ternary r12 r2.player1[0u32] r2.player1[1u32] into r13;
    ternary r11 r13 0u128 into r14;
    and r6.players_folded 2u8 into r15;
    is.neq r15 0u8 into r16;
    not r16 into r17;
    gte r2.player2[0u32] r2.player2[1u32] into r18;
    ternary r18 r2.player2[0u32] r2.player2[1u32] into r19;
    ternary r17 r19 0u128 into r20;
    and r6.players_folded 4u8 into r21;
    is.neq r21 0u8 into r22;
    not r22 into r23;
    gte r2.player3[0u32] r2.player3[1u32] into r24;
    ternary r24 r2.player3[0u32] r2.player3[1u32] into r25;
    ternary r23 r25 0u128 into r26;
    gte r14 r20 into r27;
    gte r14 r26 into r28;
    and r27 r28 into r29;
    gte r20 r26 into r30;
    ternary r30 2u8 3u8 into r31;
    ternary r29 1u8 r31 into r32;
    get chips[r0] into r33;
    add r33.player1_bet r33.player2_bet into r34;
    add r34 r33.player3_bet into r35;
    is.eq r32 1u8 into r36;
    add r33.player1 r35 into r37;
    ternary r36 r37 r33.player1 into r38;
    is.eq r32 2u8 into r39;
    add r33.player2 r35 into r40;
    ternary r39 r40 r33.player2 into r41;
    is.eq r32 3u8 into r42;
    add r33.player3 r35 into r43;
    ternary r42 r43 r33.player3 into r44;
    cast r38 r41 r44 0u16 0u16 0u16 into r45 as Chips;
    is.eq r45.player1 0u16 into r46;
    ternary r46 1u8 0u8 into r47;
    is.eq r45.player2 0u16 into r48;
    ternary r48 2u8 0u8 into r49;
    or r47 r49 into r50;
    is.eq r45.player3 0u16 into r51;
    ternary r51 4u8 0u8 into r52;
    or r50 r52 into r53;
    is.eq r53 6u8 into r54;
    branch.eq r54 false to end_then_0_12;
    branch.eq true true to end_otherwise_0_13;
    position end_then_0_12;
    is.eq r53 5u8 into r55;
    branch.eq r55 false to end_then_1_14;
    branch.eq true true to end_otherwise_1_15;
    position end_then_1_14;
    is.eq r53 3u8 into r56;
    branch.eq r56 false to end_then_2_16;
    branch.eq true true to end_otherwise_2_17;
    position end_then_2_16;
    position end_otherwise_2_17;
    position end_otherwise_1_15;
    position end_otherwise_0_13;
    and r6.dealer_button 1u8 into r57;
    is.neq r57 0u8 into r58;
    and r6.dealer_button 2u8 into r59;
    is.neq r59 0u8 into r60;
    ternary r60 4u8 1u8 into r61;
    ternary r58 2u8 r61 into r62;
    sub r6.remaining_hands 1u8 into r63;
    is.eq r63 0u8 into r64;
    mul r6.sb 2u16 into r65;
    mul r6.bb 2u16 into r66;
    ternary r64 r65 r6.sb into r67;
    ternary r64 r66 r6.bb into r68;
    is.eq r63 0u8 into r69;
    ternary r69 10u8 r63 into r70;
    add r6.hands_played 1u8 into r71;
    cast r6.player1 r6.player2 r6.player3 r6.buy_in r6.deck 29u8 r62 r53 r53 0u8 r67 r68 r70 r71 0u16 into r72 as Game;
    set r2 into cards[r0];
    set r45 into chips[r0];
    set r72 into games[r0];
